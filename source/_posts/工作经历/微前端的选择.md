---
title: 微前端的选择
tags:
  - 盛趣游戏
categories:
  - 工作经历
hidden: false
abbrlink: 1990516674
date: 2022-11-14 17:35:37
---

# 传统 Web 应用的利弊

传统的前端研发模式进行开发，那么此时有两种项目设计策略：

1. 将平台内多个系统放置同一个代码仓库维护 ，采用 SPA（Single-page Application） 单页应用模式
2. 将系统分为多个仓库维护，在首页聚合所有平台的入口，采用 MPA（Multi-page Application）多页应用模式

> 若采用多个系统放置同一个项目内维护：

- 优势：
  - 统一的权限管控、统一的 Open API 开发能力
  - 更好的代码复用，基础库复用
  - 统一的运营管理能力
  - 不同系统可以很好的通信
  - SPA 应用特有优势：
  - 更好的性能
  - 具备局部更新，无缝的用户体验
  - 提前预加载用户下一页的内容
- 劣势：
  - 代码权限管控问题
  - 项目构建时间长
  - 需求发布相互阻塞
  - 代码 commit 混乱、分支混乱
  - 技术体系要求统一
  - 无法同时灰度多条产品功能
  - 代码回滚相互影响
  - 错误监控无法细粒度拆分

> 若采用拆分成多个仓库维护

- 优势
  - 可以以项目维度拆分代码，解决权限管控问题
  - 仅构建本项目代码，构建速度快
  - 可以使用不同的技术体系
  - 不存在同一个仓库维护时的 commit 混乱和分支混乱等问题
  - 功能灰度互不影响
- 劣势
  - 用户在使用时体验割裂，会在不同平台间跳转，无法达到 SPA 应用带来的用户体验
  - 只能以页面维度拆分，无法拆分至区块部分，只能以业务为维度划分
  - 多系统同灰度策略困难
  - 公共包基础库重复加载
  - 不同系统间不可以直接通信
  - 公共部分只能每个系统独立实现，同一运维通知困难
  - 产品权限无法进行统一收敛

# 微前端概念与微服务的差别

微前端是指存在于浏览器中的微服务。

微前端作为用户界面的一部分，通常由许多组件组成，并使用类似于React、Vue和Angular等框架来渲染组件。

每个微前端都拥有独立的 git 仓库、package.json 和构建工具配置。因此，每个微前端都拥有独立的构建进程和独立的部署/CI。这通常意味着，每个仓库能快速构建。

[对比微服务的内容](https://zh-hans.single-spa.js.org/docs/microfrontends-concept#%E5%AF%B9%E6%AF%94%E5%BE%AE%E6%9C%8D%E5%8A%A1)

# 微前端的选择与考虑

目前微前端的实现方式有以下几种：
- 路由分发：
  - 优点：开发成本低，维护成本低，可行性高，不限技术栈，实现简单
  - 缺点：无法做到应用镶嵌
- iFrame：
  - 优点：开发成本低，维护成本低，可行性高，不限技术栈，实现简单
  - 缺点：无法 SEO；与主应用共享连接池，会影响页面的并行加载；兼容性差
- 纯 Web Components：开发成本高，维护成本低，可行性高，不限技术栈，实现简单
- 结合 Web Components：开发成本高，维护成本低，可行性高，不限技术栈，实现简单

我们前端团队在考虑框架有以下三种：
- Single-Spa：最早的前端微服务 Javascript 框架，兼容多种前端技术栈
- Qiankun：基于 Single-Spa，阿里系开源微前端框架
  - 是通过监听 url change 事件，在路由变化时匹配到渲染的子应用并进行渲染，**这个思路也是目前实现微前端的主流方式。**
- Micro-app：是京东零售推出的基于类 WebComponent 进行渲染，从组件化的思维实现的微前端技术
  - 当子应用支持 ssr 时，可配置支持 ssr

| 对比项 | Single-Spa | Qiankun | Micro-app |
| -- | -- | -- | -- |
| 框架体积 | 20kb | 94kb | 30kb |
| 渲染原理 | 路由监听 | 路由监听 + 手动渲染 | [customElement](https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_custom_elements) |
| 接入成本 | 高 | 中 | 低 |
| 多框架兼容（vue、react、angular）| ✅ | ✅ | ✅ |
| CSS 样式隔离 | ❌ | ✅ | ✅ |
| JS 沙箱 | ❌ | ✅ | ✅ |
| [shadowDom](https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_shadow_DOM) | ❌ | ✅ | ✅ |
| 预加载 | ❌ | ✅ | ✅ |
| webpack 兼容 | ✅ | ✅ | ✅ |
| vite 兼容 | ❌ | ❌ | ✅(代价关闭沙箱) |

1. Single-Spa
  - 不限技术栈
  - 支持独立部署每一个单页面应用
  - 在同一页面上使用多个前端框架，而不用刷新页面
2. Qiankun
  - 基于 single-spa 封装，提供了更加开箱即用的 API
  - 不限技术栈
  - HTML Entry 接入方式，让你接入微应用像使用 iframe 一样简单
  - 样式隔离，确保微应用之间样式互相不干扰
  - JS 沙箱，确保微应用之间全局变量/事件不冲突
  - 资源预加载，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度
3. Micro-app
  - 使用简单，接入微前端成本低
  - 零依赖
  - 兼容所有框架（不需要提供脚手架工具）
  - 提供了JS沙箱、样式隔离、元素隔离、预加载、资源地址补全、插件系统、数据通信等一系列完善的功能

鉴于我们团队需要兼容 IE 低版本浏览器，再加上 Qiankun 的社区较 Micro 的久，有什么问题也能更快解决，所以选择了 Qiankun。

# 微前端与 SSR 微服务

[https://qinzhiqiang.cn/2020/09/微前端与ssr微服务/](https://qinzhiqiang.cn/2020/09/%E5%BE%AE%E5%89%8D%E7%AB%AF%E4%B8%8Essr%E5%BE%AE%E6%9C%8D%E5%8A%A1/)

# 使用 Qiankun 遇到的坑

在负责的内容编辑器内，经常会因为要在线修改 [中文].csv 文件内容去打开一个页签 tag，页签 tag 是监听路由变化来差异化添加并匹配活跃 tag。

对于中文，我们一向会通过 `encodeURIComponent` 方法进行转码再拼接，在 Qiankun 中是主应用通过手动监听路由的变化再根据路由来匹配反应给子应用，问题就出现在主应用传递到子应用的路由自动将转码后的中文又反转回中文了，导致传给子应用的路由里的中文又通过 `decodeURI` 转码回来，造成了创建了两个因为路由里中文不同的两个 tag。

因为我们注定要将中文转码后再 `pushstate`，所以我这边的做法是在子应用的 `router.beforeEach` 中对中文进行拦截，再将中文手动进行 `encodeURIComponent` 再 `next(path)` 出去。