---
title: P9 使用高阶组件对代码做增强
tags: []
categories:
  - React
abbrlink: 1177118690
date: 2021-12-07 19:30:50
---

> 高阶组件的使用场景有很多，这里只是对其中的一些做示例，具体延伸还是需要具体思考！
> 
> 我认为，一般复用性的代码都可以通过高阶组件来做一层封装之后，再使用。

# 1. 对 Props / 其他属性（例如 context） 的增强

## 1.1 Props 增强

比如在一个场景中：有多个不同的子组件，都需要相同的数据字段，此时一般情况下是：

``` javascript
import React, { PureComponent } from 'react';

function Home(props) {
    return (
        <h2>{`名字：${props.name}; 年龄：${props.age}; 地区：${props.point}`}</h2>
    )
}
function About(props) {
    return (
        <h2>{`名字：${props.name}; 年龄：${props.age}; 地区：${props.point}`}</h2>
    )
}


class App extends PureComponent {
    constructor(props) {
        super(props);
        this.state = {}
    }
    render() { 
        return (
            <div>
                <Home name="Jamediii" age="18" tag="nav 标签"/>
                <About name="Jamediii" age="18" tag="nav 标签"/>
            </div>
        );
    }
}
 
export default App;
```

这样，当你需要再往这些子组件中添加另外的相同属性时，需要每个单独的去添加，有时就会导致部分子组件忘记添加。

此时，就可以利用高阶函数组件 `enhanceComponent`，来对这一类的子组件做统一化处理，这样子：

``` javascript
function enhanceComponent(WrappedComponent) {
    return function NewComponent (props) {
        return (
            <WrappedComponent {...props} tag="nav 标签" />
        )
    }
}
```

之后，将子组件做处理：

``` javascript
const EnhanceHome = enhanceComponent(Home)
const EnhanceAbout = enhanceComponent(About)
```

再在 `App` 组件中将 `Home -> EnhanceHome, About -> EnhanceAbout` 替换，通用的属性与方法可以在 `enhanceComponent` 中实现即可 ：

``` javascript
...
<EnhanceHome name="Jamediii" age="18"/>
<EnhanceAbout name="Jamediii" age="18"/>
...
```

## 1.2 对 Context 的增强

在一般情况下，多个子组件中使用同一 `Context` 时：

``` javascript
import React, { PureComponent } from 'react';

const UserContext = React.createContext({
    username: 'jamediii',
    age: 18,
    origin: 'px'
})

function Home(props) {
    return (
        /* 需要进行一次 UserContext.Consumer */
        <UserContext.Consumer>
            {
                context => {
                    return (
                        <h2> Home :{`名字：${context.username}; 年龄：${context.age}; 地区：${context.origin}`}</h2>
                    )
                }
            }
        </UserContext.Consumer>
    )
}
function About(props) {
    return (
         /* 需要进行一次 UserContext.Consumer */
        <UserContext.Consumer>
            {
                context => {
                    return (
                        <h2> About :{`名字：${context.username}; 年龄：${context.age}; 地区：${context.origin}`}</h2>
                    )
                }
            }
        </UserContext.Consumer>
    )
}


class App extends PureComponent {
    constructor(props) {
        super(props);
        this.state = {
            username: 'jam',
            age: 25,
            origin: 'px'
        }
    }
    render() { 
        return (
            <div>
                <UserContext.Provider value={this.state}>
                    <Home/>
                    <About/>
                </UserContext.Provider>
            </div>
        );
    }
}
 
export default App;
```

这样子，当你有更多的子组件需要使用到相同的 `Context` 时，需要同样的写一些相同的代码。

因此，可以利用高阶函数组件对 `Context` 做增强：

``` javascript
/* 高阶函数组件 */
function enhanceComponent(WrappedComponent) {
    return function NewComponent (props) {
        return (
             /* 对相同的组件做统一的 UserContext.Consumer */
            <UserContext.Consumer>
                {
                    context => {
                        return (
                            // 将获取到的 context 传入到被包裹组件 WrappedComponent 的 props 中
                            // 当 context & props 中有相同的属性名时，后面的对象的属性值会覆盖前面的对象的属性值。
                            <WrappedComponent {...context} {...props} />
                        )
                    }
                }
            </UserContext.Consumer>
        )
    }
}
```

> 注意：当 context & props 中有相同的属性名时，位于后面的对象的属性值会覆盖前面的对象的属性值。

之后，对子组件做处理，此时子组件中就可以不需要再进行 `UserContext.Consumer`：

``` javascript
...
function Home(props) {
    return (
        <h2> Home :{`名字：${props.username}; 年龄：${props.age}; 地区：${props.origin}`}</h2>
    )
}
function About(props) {
    return (
        <h2> About :{`名字：${props.username}; 年龄：${props.age}; 地区：${props.origin}`}</h2>
    )
}

const EnhanceHome = enhanceComponent(Home)
const EnhanceAbout = enhanceComponent(About)

class App extends PureComponent {
    ...
    render() { 
        return (
            <div>
                <UserContext.Provider value={this.state}>
                    {/* 由于 props 位于后者，所以会覆盖 context 中的属性值 */}
                    <EnhanceHome username="ajax"/>  
                    <EnhanceAbout/>
                </UserContext.Provider>
            </div>
        );
    }
    ...
}
...
```

# 2. 对组件的渲染增强

有时有这么一个场景中：组件的是否渲染可能会需要依照一些属性来做判断，你可以在每个需要判断的地方写相同的 三元运算符 比较，也可以是使用高阶函数将相同的操作做统一的处理。

一般的写法：

``` javascript
...
function CartPage(props) {
    return (
        <div>Shopping Cart</div>
    )
}
function LoginPage(props) {
    return (
        <div>Login Page</div>
    )
}

class App extends PureComponent {
    state = {
        isLogin: false
    }
    render() { 
        return (
            <div>
                {this.state.isLogin ? <CartPage /> : <LoginPage />}
            </div>
        );
    }
}
...
```

这样做就需要在每一个有相同逻辑的组件中进行相同的操作，所以我们可以使用高阶组件 `withAuth` 做层封装：

``` javascript
function withAuth(WrappedComponent) {
    return (props) => {
        if (props.isLogin) {
            return <WrappedComponent />
        } else {
            return <LoginPage />
        }
    }
}
```

之后，对需要进行权限控制的组件操作 & 使用：

``` javascript
...
const AuthCart = withAuth(CartPage)

class App extends PureComponent {
    state = {
        isLogin: false
    }
    render() { 
        return (
            <div>
                {this.state.isLogin ? <CartPage /> : <LoginPage />}
                <AuthCart isLogin={this.state.isLogin}/>
                <button onClick={e => this.handleLogin()}>登录</button>
            </div>
        );
    }
    handleLogin () {
        this.setState({
            isLogin: !this.state.isLogin
        })
    }
}
...
```

# 3. 高阶组件的意义

我们会发现，利用高阶组件可以针对某些 React 代码进行更加优雅统一的处理。

但其实，早期 React 有提供组件之间的一种复用方式是 mixin，目前已经不在建议使用：
- Mixin 可能会互换依赖，互相耦合，不利于代码的维护
- 不同的 Mixin 中的方法可能会互相冲突
- Mixin 非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性

当然 HOC 也有自己的一些缺陷：
- HOC 需要在原组件上进行一层包裹或者嵌套，如果大量使用 HOC，将会有很多的嵌套，这会让调试变得非常复杂
- HOC 可以劫持 props，在不遵守约定的情况下也可能造成冲突