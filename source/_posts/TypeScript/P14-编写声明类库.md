---
title: P14 编写声明类库
tags:
  - null
categories:
  - TypeScript
hidden: false
date: 2022-02-25 20:44:55
abbrlink:
---

# 编写声明类库

声明类库分为三种：

1. 全局类库
2. 模块类库
3. `umd` 类库

## 引入 `jquery` 库

``` typescript
import $ from 'jquery'
```

`jquery` 库是 `Umd` 库，能够模块 / 全局引用，在这里是模块引入，但是在 `ts` 中是无法直接使用 `jquery` 库的，会报错，报错信息会提示需要引入一个包 `@types/jquery` ，或者自己去编写。

这之后，就可以正常的使用了：

``` typescript
...
$('#app').css('color', 'red')
```

## 全局类库的编写与使用

在项目目录下给 `global-lib.js` 文件编写：

``` javascript
function globalLib (options) {
    console.log(options)
}
globalLib.version = '1.0.0'
globalLib.doSomething = () => {
    console.log('globalLib do something')
}
```

使用该全局类库的话，需要在入口 `index.html` 文件中通过 `<script></script>` 标签引入进来：`<script src="./global-lib.js"></script>` 。之后在 `index.ts` 中编写：

``` typescript
...
globalLib({x: 1}) // 此时会报错：找不到名称“globalLib”。
```

报错的原因是：在 `.ts` 中无法直接引用 `.js`，需要将 `global-lib.js` -> `global-lib.ts`。一般类库的声明文件必须是 `xxx.d.ts`。具体的代码在 `global-lib.d.ts` 中：

``` typescript
declare function globalLib (options: globalLib.Options): void

namespace globalLib {
    const version: string;
    function doSometing(): void
    interface Options {
        [key: string]: any
    }
}
```

在这里我们使用到了 `declare` 关键字，它可以为外部变量提供类型声明。

需要注意的点有：

1. 在源码 `global-lib.js` 中有一个全局的函数 `globalLib` ，所以在 `global-lib.d.ts` 中也会暴露出一个全局的函数，并且通过 `declare` 关键字将该函数。

## 模块类库的编写与使用

在项目目录下创建 `module-lib.js` 文件并编写：

``` javascript
const version = '1.0.0'
function doSomething () {
    console.log('moduleLib do something');
}
function moduleLib (options) {
    console.log(options);
}
moduleLib.version = version
moduleLib.doSomething = doSomething
export default moduleLib // module.exports = moduleLib
```

之后在 `index.ts` 中引入该模块文件，

``` typescript
...
import moduleLib from './module-lib' // 此时会报错：无法找到模块“./module-lib”的声明文件。
```

此时在目录下创建 `module-lib.d.ts` 文件并编写内容：

``` typescript
declare function moduleLib (options: Options): void

interface Options {
    [key: number]: any
}

declare namespace moduleLib {
    const version: string
    function doSomething ():void
}

export = moduleLib // 这里是与全局类库的最大区别，需要将 moduleLib 导出。而且采用 export 导出是为了兼容 commonjs && ES6
```

此时， `index.ts` 文件中的 `moduleLib` 导入就不会再报错了。

## `Umd` 类库的编写与使用

在项目中创建 `umd-lib.js` 文件，在该文件下编写：

``` javascript
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define(factory)
    } else if (typeof module === 'function' && module.exports) {
        module.exports = factory()
    } else {
        root.umdLib = factory()
    }
}(this, function () {
    return {
        version: '1.0.0',
        doSomething () {
            console.log('umdLib do something');
        }
    }
}))
```

然后再在 `index.ts` 中引入该文件：

``` typescript
...
import umdLib from './umd-lib' //此时也会报错：无法找到模块“./umd-lib”的声明文件。
```

这时，我们就要创建一个声明文件 `umd-lib.d.ts`：

``` typescript
declare namespace umdLib {
    const version: string
    function doSomething ():void
}

export as namespace umdLib // 专门为 umd 库设置的语句。这条语句是不可缺少的
export = umdLib
```
此时， `index.ts` 文件中的 `umdLib` 导入就不会再报错了。这种就是模块化导入，我们也可以对 `umd` 类库进行全局导入，也是与 全局类库 导入一致，在 `index.html` 中通过 `<script></script>` 标签导入：
`<script src="./umd-lib.js"></script>`

当将 `umd` 类库以全局引入时，`ts` 会提示报错：`umdLib` 指 UMD 全局，但当前文件是模块。请考虑改为添加导入。

此时我们就可以通过修改 `tsconfig.json` 的配置项来忽略该报错：`"compilerOptions.allowUmdGlobalAccess": true`。

## 给一些类编写自定义的方法

### 以 `moment` 为例，给模块类库添加自定义方法：

1. 先安装 `moment` 库： `npm i moment -S`
2. 想在 `monemt` 中自定义一些方法：

``` typescript
import m from 'moment'

m.myFunction = () => {} // 会报错：类型“typeof moment”上不存在属性“myFunction”。
```

3. 通过 `declare` 处理这个问题，关键是： `declare module xx {}`

``` typescript
import m from 'moment'
declare module 'moment' {
    export function  myFunction (): void
}
m.myFunction = () => {}
```

### 给全局类库添加自定义方法

也是通过 `declare` 来处理，但是语句为：

``` typescript
declare global {
    namespace xxx {
        ...
    }
}
```

具体以 `globalLib` 为例：

``` typescript
declare global {
    namespace globalLib {
        function doAnything (): void
    }
}
globalLib.doAnything = () => {
    console.log('globalLib do Anything');
}
```

### 声明文件间的依赖

以 `jquery` 为例：在 `node_module/@types/jquery` 文件夹中

1. 先查看 `package.json` 文件下的 `types` 字段，该字段就是整个 `jquery` 的声明文件入口: `"types": "index.d.ts", `

``` typescript
/// <reference types="sizzle" />
/// <reference path="JQueryStatic.d.ts" />
/// <reference path="JQuery.d.ts" />
/// <reference path="misc.d.ts" />
/// <reference path="legacy.d.ts" />

export = jQuery;
```

在这个文件下前缀都是贡献者，只有最后是一些 `reference` 引用，最后导出 `jQuery`。而这些依赖又能分为两种（模块依赖 & ）：

1. 模块依赖：是使用的 `types` 属性。

`/// <reference types="sizzle" />` 这句话的含义就是，`ts` 会在这个 `@types` 目录下寻找这个 `sizzle` 模块

2. 路径依赖： 使用 `path` 属性，这是一个相对的路径。

`/// <reference path="JQueryStatic.d.ts" />` 意思就是寻找与 `index.d.ts` 同级的文件。