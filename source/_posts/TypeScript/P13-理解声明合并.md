---
title: P13 理解声明合并
tags:
  - null
categories:
  - TypeScript
hidden: false
abbrlink: 3943423985
date: 2022-02-25 20:41:05
---

# 理解声明合并

声明合并是 `TS` 中的一个独特概念，所谓声明合并就是指编译器会把程序多个地方具有相同声明合并为一个声明，这样做有一个好处，可以将程序中散落在各处的声明合并在一起。比如你在程序中多个地方定义了同一个名字的接口，那么你在使用接口的时候，就会对这个多处的定义同时具有感知能力。通过声明合并就可以避免对接口成员的遗漏

## 多种声明合并

### 接口的声明合并

``` typescript
interface A {
    x: number
}
interface A {
    y: number
}
let a: A = {
    x: 1,
    y: 2
} // 会提示需要 x, y
```

当你在第一个接口 `A` 中定义 `y: string` ,那么其他相同名称中的 `y` 也得是相同类型，否则回报错！

当你在接口中声明方法，那会实现方法的重载。

``` typescript
interface A {
    ...
    foo(bar: string): number
}
interface A {
    ...
    foo(bar: number): string;
    foo(bar: string[]): number[]
}
let a: A = {
    ...
    foo (bar: any) {
        return bar
    }
}
```

函数重置的过程中呢需要注意函数声明的顺序，因为编译器会按顺序匹配，那么在接口合并的时候，顺序如何确定的呢？有几个原则

1. 在接口内部按书写顺序确定
2. 接口之间呢，会按照后面的接口会排在前面

``` typescript
interface A {
    ...
    foo(bar: string): number // 3
}
interface A {
    ...
    foo(bar: number): string; // 1
    foo(bar: string[]): number[] // 2
}
```

3. 但是有一个例外，当函数的参数是 字符串字面量 的话，那这个声明就会提升到整个函数声明的最顶端。

``` typescript
interface A {
    ...
    foo(bar: string): number // 5
    foo(bar: 'a'): number // 2
}
interface A {
    ...
    foo(bar: number): string; // 3
    foo(bar: string[]): number[] // 4
    foo(bar: 1): string // 1
}
```

### 命名空间 与 其他类型 的合并

> 需要注意的一个问题是：
> 1. 命名空间中导出的成员是不允许重复定义的。
> 2. 与 其他类型 合并时，一定得放在 其他类型 的后面。

1. 与 函数 声明合并

``` typescript
function Lib () {}
namespace Lib {
    export let version = 'v1.0'
}
console.log(Lib.version) // v1.0
```

在 `js` 中给一个函数创建过程中增加一些属性是很常见的模式，通过命名空间和函数的声明合并，也可以实现这类模式。

2. 与 类 声明合并

``` typescript
class C {}
namespace C {
    export let status = 1
    export function getStatus () {
        return status
    }
}
console.log(C);
console.log(C.status)
console.log(C.getStatus()); // 1
```

命名空间内导出的 变量 & 方法 相当于给类添加了一些静态的 属性 & 方法。而不是在 `new` 出的对象中。

3. 与 枚举 声明合并

``` typescript
enum Color {
    Red,
    Blue,
    Yello
}
namespace Color {
    export function getRed () {
        return Color.Red
    }
}
console.log(Color);
console.log(Color.getRed()); // 0
```
