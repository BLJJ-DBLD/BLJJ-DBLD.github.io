---
title: P6 类
tags:
  - null
categories:
  - TypeScript
hidden: false
abbrlink: 1054832788
date: 2022-01-23 08:59:26
---

## 继承和成员修饰符

``` typescript
interface Position {
  x: string,
  y: string,
  [key: string]: any
}
class Dog {
  name: string
  constructor (name: string) {
    this.name = name
  }
  run (position: Position) {
    console.log(`前往坐标 X:${position.x}, Y:${position.y}`);
  }
}
```

> 假设没有 `this.name = name` 语句，`name: string` 将会报错，原因是属性 `name` 没有初始值设定项，也没有在构造函数中明确分配。

解决方案有二：
1. 设置 `name` 为可选值：`name?: string`
2. 设置 `name` 默认值：`name: string = 'Tom'`

## 类中的成员修饰符

> ❗ 由 ts 扩展， ES 中不存在修饰符

1. public：公有类成员，允许被继承与实例化
2. private：私有类成员，不允许被继承与实例化，只能在类内部使用
3. protected：保护类成员，只能在类 / 子类中被访问，而不能在实例中访问
4. static：静态类成员，只能通过类名来调用，而不能通过子类调用
5. readonly：只读属性，有两个注意点：
  - 不能被修改
  - 声明时必须赋值

需要注意的是，除了类的成员可以实现修饰符，构造函数的参数也可以添加修饰符，它的作用是：**自动把参数变成实例的属性，这样就可以省略在类中的定义了**。

``` typescript
class Dog {
  public name: string = 'Tom' // 公开类
  static food: string = 'bones' // 静态类
  readonly race: string = 'animal' // 只读属性
  protected constructor (name: string) { // 保护类
    this.name = name
  }
  private run (position: Position) { // 私有类
    console.log(`前往坐标 X:${position.x}, Y:${position.y}`);
  }
}
// 哈巴狗 Pug
class Pug extends Dog {
  color: string = 'white'
  constructor (name: string, public sex: string = 'male', color: string) {
    super(name)
    this.sex = sex
    this.color = color
  }
}
const pug = new Pug('xh', 'female', 'red')
console.log(pug);
```

## 抽象类与多态

### 抽象类(`abstract` 关键字)

> ❗ 抽象类不允许被创建实例，只能被继承

``` typescript
abstract class Animal {
}
// const animal = new Animal() // 会报错：Cannot create an instance of an abstract class.
class Dog extends Animal {
  constructor (public name: string) {
    super()
    this.name = name
  }
}
```

#### 抽象方法(`abstract` 关键字)

> ❗ 明确该抽象类中声明的抽象方法会在子类中实现

``` typescript
abstract class Animal {
  eat () {
    console.log('eat');
  }
  abstract sleep(): void
}
// const animal = new Animal()
class Dog extends Animal {
  constructor (public name: string) {
    super()
    this.name = name
  }
  sleep () {
    console.log('dog sleep');
  }
}
```

#### 总结

抽象类的好处是：**抽离出一些事务的共性，这样有利于代码的复用和扩展，另外抽象类也能实现多态。**

### 多态

> 所谓的多态：在父类中定义多个抽象方法，在子类中对这些抽象方法有多种实现，在程序运行的时候，会根据不同的对象进行不同的操作。

``` typescript
class Cat1 extends Animal {
  sleep () {
    console.log('Cat sleep');
  }
}
const cat = new Cat1()
const animals: Animal[] = [dog, cat]
animals.forEach(animal => {
  animal.sleep()
})
```

#### 链式调用

> 简单理解就是对象的每个方法都返回当前对象

``` typescript
class WorkFlow {
  step1 () {
    // ...
    return this
  }
  step2 () {
    // ...
    return this
  }
}
const work = new WorkFlow()
work.step1().step2()
```

> 在继承的时候， `this` 也可以表现出**多态**，`this` 既可以是指子类也可以是指父类

``` typescript
class MyWork extends WorkFlow {
  next () {
    // ...
    return this
  }
}
const myWork = new MyWork()
myWork.next().step1().next().step2()
```