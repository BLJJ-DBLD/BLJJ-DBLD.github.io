---
title: P9.4 高级类型：条件类型
tags:
  - null
categories:
  - TypeScript
hidden: false
abbrlink: 2624511287
date: 2022-01-24 20:55:20
---
## 条件类型

代码语句： `T extends U ? X : Y`
翻译过来就是： 假如 `T` 允许继承自 `U`，那么就输出 `X` 类型，否则输出 `Y` 类型

> 条件类型使类型具有了不唯一性，同时也增加了语言的灵活性

举个例子：

``` typescript
// T extends U ? X : Y
// 定义一个条件类型别名
type TypeName<T> =
T extends string ? 'string':
T extends number ? 'number':
T extends boolean ? 'boolean' :
T extends Function ? 'function' :
T extends undefined ? 'undefined':
'object'

type stringType = TypeName<string> // 输出 字面量类型：'string'
type arrayType = TypeName<string[]> // 输出 字面量类型： 'object'
```

在此基础上，我们可以实现一个联合类型的条件类型

``` typescript
// 在上一个例子的基础上。
// (A | B) extends U ? X : Y
// 可以演变成 ->
// (A extends U ? X : Y) | (B extends U ? X : Y)
// 定义一个联合类型的条件类型
type unionType = TypeName<string | string[]> // 输出 字面量联合类型： 'string' | 'object'
```

利用这个特性，可以帮助我们去实现一些类型的过滤

再举个小例子：

``` typescript
type Diff<T, U> = T extends U ? never : T
// 上面这句代码的含义是：假如 T 能够继承自 U 时，将被过滤。
type T4 = Diff<'a' | 'b' | 'c', 'a' | 'e'> // 输出 字面量联合类型，并且过滤掉了第一个参数中的 'a'： type T4 = "b" | "c"
// 上面这句代码可以演变成 ->
// Diff<'a', 'a' | 'e'> | Diff<'b', 'a' | 'e'> | Diff<'c', 'a' | 'e'>
// never | 'b' | 'c'
// 'b' | 'c'
```

基于上面代码中的 `Diff` 类型可以做扩展，从类型中除去一些我们不需要的类型，比如 `undefined`， `null`

``` typescript
// 在 Diff 上做扩展，剔除 undefined & null 类型
type NotNull<T> = Diff<T, undefined | null>
type T5 = NotNull<string | number | undefined | null> // type T5 = string | number
```

但其实，上面提到的 `Diff` 类型，官方是有定义到的， `Exclude`。
而 `NotNull` 在官方中定义是： `NonNullable`

这里从官方的 `ReturnType` 类型，学习到了一个新的标签 `infer`，
含义是：延迟计算类型

``` typescript
/**
* Obtain the return type of a function type
*/
type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;
```

还有许多官方定义的类型，感兴趣可以去阅读看一下，学习一下思想。