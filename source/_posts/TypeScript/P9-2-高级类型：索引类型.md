---
title: P9.2 高级类型：索引类型
tags:
  - null
categories:
  - TypeScript
hidden: false
abbrlink: 1671919051
date: 2022-01-24 20:50:13
---
## 索引类型

> 索引类型，可以对对象的属性进行查询和访问，然后再配合泛型约束，就可以建立 对象，对象属性，以及属性值 之间的约束关系。

先看这个小例子

``` typescript
// 定义一个 obj 对象
let obj = {
  a: 1,
  b: 2,
  c: 3
}
// 定义一个对象中值的返回函数
function getValues (obj: any, keys: string[]) {
return keys.map(key => obj[key])
}
console.log(getValues(obj, ['a', 'b']) // 这样子就会输出 [1, 2]
// 但是如果我们的 keys 中的值不存在 obj 的属性中时， ts 并不能帮忙检测出错误
console.log(getValues(obj, ['e', 'f'])) // 会输出 [undefined, undefined]
```

所以这时，我们利用索引类型来约束 `keys`。
而为了了解索引类型，需要先了解一些概念：

1. 第一个概念是：索引类型的查询操作符。语法： `keyof T`
> `keyof T` 的含义：表示类型 `T` 的所有公共属性的字面量联合类型

举个例子：

``` typescript
interface Obj {
  a: number;
  b: string
}
// 表示类型 Obj 的所有公共属性的字面量联合类型
let key: keyof Obj // 'a' | 'b'
```

2. 第二个概念是：索引访问操作符。语法： `T[K]`
> `T[K]` 所代表含义就是：对象 `T` 中的属性 `K` 所代表的类型

再举一个例子：

``` typescript
let value: Obj['a'] // 这样就代表， value 的类型： number
```

3. 第三个概念就是：利用泛型约束。语法： `T extends U`

了解到三个概念后，就可以来改造 `getValues` 函数：

``` typescript
function reformGetValues<T, K extends keyof T> (obj: T, keys: K[]): T[K][] {
  return keys.map(key => obj[key])
}

console.log(reformGetValues(obj, ['a', 'c'])); // [ 1, 3 ]
// console.log(reformGetValues(obj, ['e', 'f'])); // 报错：不能将类型“"f"”分配给类型“"a" | "c" | "b"”。ts(2322)
```
