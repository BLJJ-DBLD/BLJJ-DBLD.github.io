---
abbrlink: 0
---
# 高级类型

## 交叉类型

``` typescript
interface DogInterface {
  run(): void
}
interface CatInterface {
  jump(): void
}
let pet: DogInterface & CatInterface // 变量 pet 就是 DogInterface & CatInterface 交叉类型
// pet 将会同时具备两个接口的所有方法
pet = {
  run () {
  console.log('跑')
  }
  jump () {
  console.log('跳')
  }
}
```

> 所以由此可以得知：从名称上看，给人的感觉交叉类型是取接口的交集，其实是并集，即多个接口中的定义都应包含在内。

## 联合类型

> 通俗的讲，联合类型就是指，声明的类型并不确定，可以为多个接口中的**某一个**

举个小例子：

``` typescript
let a: number | string = 1 || '1' // 变量 a 既可以取值数字类型 或者 字符串类型
```

### 字面量类型

有的时候呢，我们不仅需要限定一个变量的类型，而且还需要限定变量的取值在某一个特定的范围内。

``` typescript
let b: 'a' | 'b' | 'c' // 变量 b 不但被限制为取值字符串类型，而且还只能取值 a, b, c 中的某一个值
let c: 1 | 2 | 3 // 同理， 变量 c 的取值只能是 1, 2, 3
```

变量 b 不但被限制为取值字符串类型，而且还只能取值 a, b, c 中的某一个值。同理， 变量 c 的取值只能是 1, 2, 3

### 对象的联合类型

``` typescript
// 定义一个 Dog 类
class Dog implements DogInterface {
constructor (public name: string) {
this.name = name
}
run () {
console.log(this.name + '跑起来了');
}
eat () {
console.log(this.name + '在吃地上香香的粑粑');
}
}
// 定义一个 Cat 类
class Cat implements CatInterface {
constructor (public name: string) {
this.name = name
}
jump () {
console.log(this.name + '跳到好高')
}
eat () {
console.log(this.name + '在吃猫粮');
}
}

// 定义一个 枚举
enum Master {
Boy,
Gril
}
// 获得一个对象的联合类型
function getPet (master: Master) {
console.log(master);
let pet = master === Master.Boy ? new Dog('小狗') : new Cat('小猫')
return pet
}

```

当我们配合枚举 `menu` 使用：

``` typescript
// 定义一个 枚举
enum Master {
Boy,
Gril
}
// 获得一个对象的联合类型
function getPet (master: Master) {
let pet = master === Master.Boy ? new Dog('小狗') : new Cat('小猫')
return pet
}
let master = Master.Boy
console.log(master, getPet(master));

// 定义多个与半径相关的接口
interface Square {
kind: 'square';
size: number;
}
// 是不允许修改在 接口 中已定义的变量值
// let square: Square = {
// kind: 'a'
// }
interface Rectangle {
kind: 'rectangle';
width: number;
height: number;
}

// 定义一个类型别名
type Shape = Square | Rectangle

// 获取范围的函数
function area (s: Shape) {
switch (s.kind) {
case 'square':
return s.size **2;
case 'rectangle':
return s.height * s.width;
}
}
```

在此的基础上，如果我们想扩展枚举的话，就会有 bug 存在

``` typescript
interface Circle {
kind: 'circle';
r: number
}

// 定义一个类型别名
type Shape = Square | Rectangle | Circle

console.log(area({kind: 'circle', r: 1})); // 会输出 undefined
```

之后在不更改原 `area` 函数的情况下，会获取不到相应的值的，问题是 Typescript 并没有检测出错误

为了防止出现这样子的错误，一共有两种解决方案：

1. 声明函数 `area` 的返回值： `function area (s: Shape): number {...}`
2. 在 `swith` 中添加错误处理机制：

``` typescript
function area (s: Shape) {
switch (s.kind) {
case 'square':
return s.size **2;
case 'rectangle':
return s.height * s.width;
case 'circle':
return Math.PI * s.r ** 2;
default:
// 处理错误
return ((e: never) => {throw new Error(e)})(s)
}
}
console.log(area({kind: 'circle', r: 1})); // 3.141592653589793
```

> 在 `swith` 中 `never` 类型可以确保 `area` 总是穷尽 (exhaust) 了所有 `Shape` 的可能类型。