---
title: P6-前面的知识点补充
tags: []
categories:
  - React
abbrlink: 1641527773
date: 2021-12-07 06:18:59
---
# 1. setState 不可变的力量

首先我们做一个案例：
![案例图片](image_1.png)

下面是对案例的一部分实现代码：

``` javascript
...
constructor(props) {
    super(props);
    this.state = {
        friends: [{
            name: 'lacey',
            age: 18
        }, {
            name: 'jamediii',
            age: 25
        }]
    }
}
render() { 
    return (
        <div>
            <ul>
                {
                    this.state.friends.map(item => {
                        return (
                            <li key={item.name}>
                                <p>名字：{item.name}</p>
                                <p>年龄：{item.age}</p>
                            </li>
                        )
                    })
                }
            </ul>
            <button onClick={e => this.addPerson()}>添加人物</button>
        </div>
    );
}
addPerson () {
    this.state.friends.push({
        name: 'tom',
        age: 23
    })
    this.setState({
        friends: this.state.friends
    })
}
...
```

当你在启动后能够发现运行时是没有问题的，那是因为我们还未考虑到性能问题。当我们加入了 `shouldComponentUpdate` 方法（后面尽量简称为 `SCU`）对 `this.state.friends` 这个对象做浅比较时（在 `PureComponent` 类中，React 也是做了同样的比较）：

``` javascript
...
shouldComponentUpdate (nextProps, nextState) {
    if (this.state.friends !== nextState.friends) {
        return true
    }
    return false
}
...
```

会导致视图无法更新，无法更新的原因是更新后的 `nextState.friends` 的变量指针与 `state.friends` 的变量指针一致。因此我们的修改是：

``` javascript
...
addPerson () {
    // 第一种更新 friends 的方式，不推荐
    // this.state.friends.push({
    //     name: 'tom',
    //     age: 23
    // })
    // this.setState({
    //     friends: this.state.friends
    // })
    
    // 第二种更新 friends 的方式，推荐！
    // 1. 先对 this.state.friends 做浅拷贝
    // 2. 之后再将新的对象加入到这个新的 friends 数组中去。
    const friends = [...this.state.friends, {
        name: 'tom',
        age: 23
    }]
    this.setState({
        friends
    })
}
...
```

实现 `age + 1` 的操作思路也是如此：

``` javascript
...
incrementAge (index) {
    // 1. 对 this.state.friends 做一个浅拷贝
    const friends = [...this.state.friends]
    // 2. 再进行内部的操作 & setState
    friends[index].age += 1
    this.setState({
        friends
    })
}
...
```

> 需要注意的一点是，我们这里做的都只是浅拷贝，newFriends 数组内部的对象与 oldFriends 数组内部的对象保留的指针是一致的，因此当我们修改内部对象中的某一个属性时，两个数组对象中的那个内部对象是一致的。

# 2. 全局事件传递

> 在多个项目中都有事件总线（`event bus`）的概念，它是一个全局对象，可以利用它对全局的一些事件做监听与相应。
>
> 在 Vue 中，可以通过声明一个 Vue 实例快速实现一个事件总线 `event bus`；
在 React 中，需要依赖一个 events 模块包，可以通过 npm 或者 yarn 来安装，命令是：`yarn add events`

`events` 常用的 API：
- 通过模块包中的 `EventEmitter` 类来声明一个 `eventBus` 全局对象
- 发出事件：`eventBus.emit(event: string | symbol, ...args: any[])`
- 监听事件：
    - `eventBus.addListener(event: string | symbol, listener: (...args: any[]) => void)`
    - `eventBus.on(event: string | symbol, listener: (...args: any[]) => void)`
- 移除事件监听：
    - `eventBus.removeListener(event: string | symbol, listener: (...args: any[]) => void)`
    - `eventBus.off(event: string | symbol, listener: (...args: any[]) => void)`

> 有四点需要引起注意：
>
> 1. 事件的监听应该放在组件生命周期中的：componentDidMount 方法中。
> 2. 当组件内存在事件监听时，一定要在该组件内的 componentWillUnmount 方法中对事件监听做移除
> 3. 事件监听与移除事件监听的方法是一套的，addListener <->removeListerner；on <-> off
> 4. 事件监听中第二个参数函数中的参数与发出事件内的参数一一对应。

``` javascript
import React, { PureComponent } from 'react';
import { EventEmitter } from 'events';

// 1. 需要先进行 eventBus 变量声明
const eventBus = new EventEmitter()

class Home extends PureComponent {
    render() {
        return (
             <div>
                Home
             </div>
        );
    }
    handleHelloListerner (num, message) {
        console.log(num, message);
    }
    componentDidMount () {
        // 3. 对事件进行监听
        // eventBus.addListener('sayHello', this.handleHelloListerner)
        eventBus.on('sayHello', this.handleHelloListerner)
    }
    componentWillUnmount () {
        // 4. 对事件取消监听
        // eventBus.removeListener('sayHello', this.handleHelloListerner)
        eventBus.off('sayHello', this.handleHelloListerner)
    }
}

class Polife extends PureComponent {
    render() {
        return (
            <div>
                Polife
                <button onClick={e => this.emitHello()}>事件传递</button>
            </div>
        );
    }
    emitHello () {
        // 2. 事件声明
        eventBus.emit('sayHello', 123, 'hello home')
    }
}

class App extends PureComponent {
    render() { 
        return (
            <div>
                <Polife />
                <Home />
            </div>
        );
    }
}
 
export default App;
```