---
title: 亲身面经
tags:
  - null
categories:
  - 面经
hidden: true
abbrlink: 2905717361
date: 2022-03-17 13:42:27
---

## 自我介绍

- 我叫邱佛，今年26岁，毕业于东华理工大学长江学院，专业是网络工程，在学校里自主学习的前端。
- 毕业前作为前端实习生在迈坦信息科技有限公司工作，毕业后即转正入职该公司。
	- 该公司是一家致力于为企业提供技术升级，专家推荐等各种服务。
	- 我主要负责的有
		- PC端官网重构，迈科技专家库的开发
			- 官网由之前的技术对接平台，升级为技术以及需求综合大平台，极大的增加了公司影响力。
			- 专家库支持大数据渲染，便捷通过关键技术词汇查找指定专家，并引流到公众号进行一对一服务
		- 移动端创新管家，接入在公司微信公众号内，支持便捷式需求查找与在线聊天。
		- 使用的技术栈是 Nust.js，vue。
- 现在在联合见智科技有限公司担任前端开发，
	- 这家公司主要从事的是SaaS化服务产品，可定制化的本地部署平台，以及数据输出产品。
	- 我在该公司主要负责的项目有
		- 掌上见智APP-H5端，现已上线各个平台
		- 掌上见智小程序-内测版、
		- 以及多家银行债务评级系统的开发。
		- 使用的技术栈也是 vue，小程序开发使用的 uni-app

## 自身有哪些优点与缺点

- 优点：对于前沿技术希望能多了解一些，并且擅长合理地安排时间。
	- 前沿技术多了解：每天早晨会花一点时间去逛技术论坛，掘金，segmentfault。
	- 合理地安排时间：因为我经常有多个项目同时缠身，所以我特别注意时间管理，分清楚任务的优先级，这样才能高效地工作，而不至于搞得焦头烂额。比方说，我会把产品需求，测试结果，会议安排，按优先级记录在我电脑的便签里面，当完成一个就会在后面做上标记，这样我就可以将这一天，这一周，甚至是因为一些大的需求将任务安排在一个月。尽量都安排得井井有条，就不会遗漏重要的事情。

- 缺点：
	- 我觉得我有时候会过分在意别人的感受，比方说，不敢直接表达不同意见，因为害怕自己的回答不够成熟，其实这样做很不利于快速有效地开展工作。我希望自己能够逐渐学会更加爽快，对人对事更加直接。将自己即使是不成熟的想法也尽量说出来，这样既能有更深的思考也能够学到更多。
	- 我这个人面对不熟络的人容易紧张。因为老担心给别人添麻烦，但是熟悉我的人，都知道我这个人又特别话痨，我应该克服这种心理障碍，主动多跟其他人交流。

## 将最近自己做过的几个比较重要的事情梳理下，讲清楚整体架构和思考改进

混合 APP - H5 端开发。
1. JSBridge 使用

2. 版本迭代而需要添加新的桥方法，强制要求 APP 更新
 - 采用渐进增强、优雅降级
 - 这边采用渐进增强，先实现基本的不与原生有交互的版本，之后，根据版本增强功能。
 - 并且为了用户的基本体验，与原生交互功能控制在两个子迭代版本和一个基础版本内，
 	- 如果小于这两个子迭代，并且不存在基础版本中的交互，就使用 `try-catch` 捕获错误并提示用户必须升级版本才能使用新功能。

## 准备一个重要的问题，问面试官

### 假如有一面

1. 目前前端团队这边使用到的技术栈有哪些？
2. 请问公司对候选人有哪些要求？

### 假如有二面

1. 请问公司是否有技术分享交流活动？有的话，多久一次呢？
2. Code Review 如何实施？

### 假如有三面

1. 我在这个岗位上应该如何发展？会有哪些机会？
2. 入职之后在哪个项目组，项目是新成立还是已有的？

## 为何从上家公司离职

是这样子，我入职时期望的方向是做公司内部，能够提升公司影响力的 APP 项目，但因为业务的转型，公司要求我驻场银行，我服从公司安排且从年前的十一月份开始，到现在也一直在驻场开发，让我感到难受的不是更远的路程，不是驻场，而是一直在做重复的内容。我自己还是更期待一些有挑战性的任务，不喜欢做一尘不变的事情。

## 如何快速让一个数组乱序

1. 利用 Array.prototype.sort 以及 Math.random 

``` javascript
arr.sort(() => Math.random() > 0.5 ? -1 : 1)
```

2. 经典洗牌算法实现

``` javascript
function shuffle(array) { 
	let arrayLength = array.length,   
		randomIndex, //随机数   
		tempItem; //临时存储元素  
	for (let i = arrayLength - 1; i >= 0; i--) {    
		randomIndex = Math.floor(Math.random() * (i + 1));    
		tempItem = array[randomIndex];
		array[randomIndex] = array[i];
		array[i] = tempItem;
	}
	return array;
}
console.log(shuffle(arr));
```

## JSBridge 原理

![JSBridge 的作用](image_01.png)

JavaScript 是运行在一个单独的 JS Context 中（例如，WebView 的 Webkit 引擎、JSCore）。
JSBridge 实现的主要逻辑是：**通信调用（Native 与 JS 通信） 和 句柄解析调用**。（**这个流程类似于 JSONP**）

### JS 调用 Native

方法有两种：

1. Native 拦截 URL Scheme

Android 和 iOS 都可以通过拦截 URL Scheme 并解析 scheme 来决定是否进行对应的 Native 代码逻辑处理。

Web 发送 URL 请求的方法有这么几种：
- `a` 标签
- `location.href`
- 使用 `iframe.src`
- 发送 `ajax` 请求

这些方法，`a` 标签需要用户操作，`location.href` 可能会引起页面的跳转丢失调用，发送 `ajax` 请求`Android` 没有相应的拦截方法，所以使用 `iframe.src` 是经常会使用的方案。

优点：不存在漏洞问题、使用灵活，可以实现 H5 和 Native 页面的无缝切换。
  - 例如在某一页面需要快速上线的情况下，先开发出 H5 页面。某一链接填写的是 H5 链接，在对应的 Native 页面开发完成前先跳转至 H5 页面，待 Native 页面开发完后再进行拦截，跳转至 Native 页面，此时 H5 的链接无需进行修改。
缺点：使用 `iframe.src` 来发送 URL Scheme 需要对 URL 的长度作控制，使用复杂，速度较慢。

2. Native 向 Context 注入 API

基于 Webview 提供的能力，可以向 Window 上注入对象或方法。JS 通过这个对象或方法进行调用时，执行对应的逻辑操作，可以直接调用 Native 的方法。使用该方式时，JS 需要等到 Native 执行完对应的逻辑后才能进行回调里面的操作。

### Native 调用 JS

H5 将 JS 方法暴露在 Window 上给 Native 调用即可。

## CSS 样式权重

权重记忆口诀：从0开始，一个行内样式+1000；一个id选择器+100；一个属性选择器、class或者伪类+10；一个元素选择器，或者伪元素+1；通配符+0。

![CSS 权重图](image_02.png)

## 为什么使用 Vuex

**vuex 不是用来管理数据，而是用来管理数据的流动**。vuex 与 localstorage 解决的完全不是一个问题。

## Vue cli 的使用

Vue 借助 Webpack 用于快速构建标准的 Vue 项目，其作用是用配置好的模板迅速搭建起一个项目工程，省去自己手动配置 Webpack 配置文件的内容，快速上手工程级别的项目开发，降低入门门槛。

Vue 是一套用于构建用户界面的 `渐进式MVVM框架`。那怎么理解渐进式呢？渐进式含义：强制主张最少。

Vue.js包含了声明式渲染、组件化系统、客户端路由、大规模状态管理、构建工具、数据持久化、跨平台支持等，但在实际开发中，并没有强制要求开发者之后某一特定功能，而是根据需求逐渐扩展。

Vue.js的核心库只关心视图渲染，且由于渐进式的特性，Vue.js便于与第三方库或既有项目整合。

1. 双向绑定
2. 虚拟 DOM 渲染

[Diff 过程解析优秀](https://juejin.cn/post/6844904020864139278#heading-18)

[slot 总结性回答](https://ustbhuangyi.github.io/vue-analysis/v2/extend/slot.html#%E6%80%BB%E7%BB%93)

### 有哪些指令

- v-model 双向绑定数据
- v-for 列表渲染
- v-bind 动态绑定属性
- v-on 绑定事件
- v-if / v-else-if / v-else
- v-show / v-hide
- v-html 解析html标签
- v-once 进入页面时 只渲染一次 不再进行渲染
- v-cloak 防止闪烁
- v-pre 把标签内部的元素原位输出
- v-text 解析文本

### v-if 与 v-show 的区别

- 相同点：都能控制元素的隐藏显示
- 不同点：
	- v-if 是条件渲染，满足条件时，节点元素都会被渲染出来，包括事件绑定等，如果不满足条件，节点就不会被渲染出来，包括事件等。但 v-show 是借助 display:none 隐藏节点的显示，它的内容还有事件等始终都存在。
	- v-if 来回切换时，浏览器需要不停地渲染，损耗性能，所以成本很高。但是 v-show 只是隐藏显示，所以成本较低。
	- v-show 在页面初始化的时候，需要全部渲染，相对 v-if 成本要高。
	- 因此 v-if 适合用于加快初始化的渲染速度。而 v-show 适合用于频繁切换的场景。

## 在项目中，对项目做的一些优化

[性能优化操作](https://blog.csdn.net/zimeng303/article/details/113853928)

## require 和 import 的区别

- `require` 是 CommoneJS 的语法，主要是 Node.js 使用，通过 `require` 同步加载模块，`module.exports / exports` 导出内容。在规范下，每一个 JS 文件都是独立的模块，每个模块都有独立的作用域，模块内的变量都是私有变量。

- `import` 是 ESM 的语法，现代浏览器原生支持，通过 `import` 加载模块，`export` 导出内容。ESM 在支持的浏览器环境下可以直接使用，在不支持的端需要编译/打包后使用。
	- ESM 加载模块的方式取决于所处的环境，Node.js 同步加载，浏览器端异步加载。

### 静态分析

> 静态分析是指在不运行程序的条件下，进行程序分析的方法

简而言之，前文里提到的静态分析就是指在运行代码之前就可判断出代码内有哪些代码使用到了，哪些没有使用到。

### Tree Shaking

> Tree Shaking 是一个通常用于描述移除 JavaScript 上下文中的未引用代码（dead-code）行为的术语。它依赖于 ES2015 中的 import 和 export 语句，用来检测代码模块是否被导出、导入，且被 JavaScript 文件使用。

简单来说，Tree Shaking 是一种依赖 ESM 模块静态分析实现的功能，它可以在编译时安全的移除代码中未使用的部分（webpack5 对 CommonJS 也进行了支持，在此不详细展开）。

#### Q: 为什么 ESM 默认支持

A: **ES6 模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析**，这就是 tree-shaking 的基础。

#### webpack5 对 CommonJS 如何支持

[系统学习前端效率工具](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B2%BE%E8%AE%B2-%E5%AE%8C/00%20%E5%BC%80%E7%AF%87%E8%AF%8D%20%20%E5%BB%BA%E7%AB%8B%E4%B8%8A%E5%B8%9D%E8%A7%86%E8%A7%92%EF%BC%8C%E5%85%A8%E9%9D%A2%E7%B3%BB%E7%BB%9F%E6%8E%8C%E6%8F%A1%E5%89%8D%E7%AB%AF%E6%95%88%E7%8E%87%E5%B7%A5%E7%A8%8B%E5%8C%96.md)


## 伪类和伪元素的区别

### 伪类

伪类是选择器的一种，它用于选择处于特定状态的元素，比如当鼠标指针悬浮在元素上面的时候。

伪类就是开头为冒号的关键字：`:pseudo-class-name`

### 伪元素

不过表现得是像你往标记文本中加入全新的 HTML 元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号 `::`。

## addEventListener 第三个参数

[MDN AddEventListener](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener)

options:
	- `capture(Boolean)`: 表示 `listener` 会在该类型的事件捕获阶段传播到该 `EventTarget` 时触发。
	- `once(Boolean)`: 表示 `listener 在添加之后最多只调用一次`。**如果是 true， listener 会在其被调用之后自动移除。**
	- `passive(Boolean)`: 设置为 true 时，表示 `listener` 永远不会调用 `preventDefault()`。如果 `listener` 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。

### 使用 passive 改善的滚屏性能

根据规范，`passive` 选项的默认值始终为 false。但是，当处理某些触摸事件（以及其他）的事件监听器在尝试处理滚动时会有阻止浏览器的主线程的可能性，从而导致滚动处理期间性能可能大大降低。

为防止出现此问题，某些浏览器（特别是Chrome和Firefox）已将文档级节点 `Window`，`Document` 和`Document.body` 的 `touchstart (en-US)` 和 `touchmove (en-US)` 事件的 `passive` 选项的默认值更改为 true。这可以防止调用事件监听器，因此在用户滚动时无法阻止页面呈现。

添加 `passive` 参数后，`touchmove` 事件不会阻塞页面的滚动（同样适用于鼠标的滚轮事件）。

> 注意：那些不支持参数 options 的浏览器，会把第三个参数默认为 useCapture，即设置 useCapture 为 true

通过将 `passive` 的值显式设置为 false 来覆盖此行为

``` javascript
/* Feature detection */
/* 特征检测：读取 test 中的第三个参数，来判断是否存在 options.passive。 */
var passiveIfSupported = false;

try {
  window.addEventListener(
		"test",
		null,
		Object.defineProperty(
			{},
			"passive",
			{ get: function() { passiveIfSupported = { passive: true }; }
		})
	);
} catch(err) {}

window.addEventListener('scroll', function(event) {
  /* do something */
  // can't use event.preventDefault();
  // 不能使用 event.preventDefault()
}, passiveIfSupported );
```