---
title: 亲身面经
tags:
  - null
categories:
  - 面经
hidden: true
abbrlink: 2905717361
date: 2022-03-17 13:42:27
---

## 自我介绍

- 我叫邱佛，今年26岁，毕业于东华理工大学长江学院，专业是网络工程，在学校里自主学习的前端。
- 毕业前作为前端实习生在迈坦信息科技有限公司工作，毕业后即转正入职该公司。
	- 该公司主要起到一个高校与企业间的桥梁作用，为他们牵线搭桥。
	- 我主要负责的有官网重构，移动端创新管家，以及迈科技专家库的构建与开发，使用的技术栈是 vue。
- 现在在联合信用投资咨询有限公司担任前端开发，
	- 这家公司主要从事的是SaaS化服务产品，可定制化的用户本地部署平台，以及数据输出产品。
	- 我在该公司主要负责的项目有混合 App-H5 端、微信小程序、以及多个债评系统的开发。使用的技术栈也是 vue，小程序开发使用的 uni-app

## 自身有哪些优点与缺点

- 优点：我擅长合理地安排时间，因为我经常有多个项目同时缠身，所以我特别注意时间管理，分清楚任务的优先级，这样才能高效地工作，而不至于搞得焦头烂额。比方说，我会把产品需求，测试结果，会议安排，按优先级记录在我电脑的便签里面，当完成一个就会在后面做上标记，这样我就可以将这一天，这一周，甚至是因为一些大的需求将任务安排在一个月。尽量都安排得井井有条，就不会遗漏重要的事情。

- 缺点：我觉得我有时候会过分在意别人的感受，比方说，不敢直接表达不同意见，因为害怕自己的回答不够成熟，其实这样做很不利于快速有效地开展工作。我希望自己能够逐渐学会更加爽快，对人对事更加直接。将自己即使是错误的思考也尽量说出来，这样既能有更深的思考也能够学到更多。

## 将最近自己做过的几个比较重要的事情梳理下，讲清楚整体架构和思考改进

混合 APP - H5 端开发。
1. JSBridge 使用

2. 版本迭代而需要添加新的桥方法，强制要求 APP 更新
 - 采用渐进增强、优雅降级
 - 这边采用渐进增强，先实现基本的不与原生有新交互的版本，之后，根据版本增强功能。
 - 并且为了用户的基本体验，与原生交互功能控制在两个子迭代版本和一个基础版本内，
 	- 如果小于这两个子迭代，并且不存在基础版本中的交互，就使用 `try-catch` 捕获错误并提示用户必须升级版本才能使用新功能。

## 准备一个重要的问题，问面试官

### 假如有一面

1. 目前前端团队这边使用到的技术栈有哪些？
2. 请问公司对候选人有哪些要求？

### 假如有二面

1. 请问公司是否有技术分享交流活动？有的话，多久一次呢？
2. Code Review 如何实施？

### 假如有三面

1. 我在这个岗位上应该如何发展？会有哪些机会？
2. 入职之后在哪个项目组，项目是新成立还是已有的？

## 为何从上家公司离职

是这样子，我入职时期望的方向是做公司内部，能够提升公司影响力的 APP 项目，但因为业务的转型，公司要求我驻场银行，我服从公司安排且从年前的十一月份开始，到现在也一直在驻场开发，让我感到难受的不是路程，不是驻场，而是一直在做重复的内容。我自己还是更期待一些有挑战性的任务，不喜欢做一尘不变的事情。

## 如何快速让一个数组乱序

1. 利用 Array.prototype.sort 以及 Math.random 

``` javascript
arr.sort(() => Math.random() > 0.5 ? -1 : 1)
```

2. 经典洗牌算法实现

``` javascript
function shuffle(array) { 
	let arrayLength = array.length,   
		randomIndex, //随机数   
		tempItem; //临时存储元素  
	for (let i = arrayLength - 1; i >= 0; i--) {    
		randomIndex = Math.floor(Math.random() * (i + 1));    
		tempItem = array[randomIndex];
		array[randomIndex] = array[i];
		array[i] = tempItem;
	}
	return array;
}
console.log(shuffle(arr));
```

## JSBridge 原理

![JSBridge 的作用](image_01.png)

JavaScript 是运行在一个单独的 JS Context 中（例如，WebView 的 Webkit 引擎、JSCore）。
JSBridge 实现的主要逻辑是：**通信调用（Native 与 JS 通信） 和 句柄解析调用**。（**这个流程类似于 JSONP**）

### JS 调用 Native

方法有两种：

1. Native 拦截 URL Scheme

Android 和 iOS 都可以通过拦截 URL Scheme 并解析 scheme 来决定是否进行对应的 Native 代码逻辑处理。

Web 发送 URL 请求的方法有这么几种：
- `a` 标签
- `location.href`
- 使用 `iframe.src`
- 发送 `ajax` 请求

这些方法，`a` 标签需要用户操作，`location.href` 可能会引起页面的跳转丢失调用，发送 `ajax` 请求`Android` 没有相应的拦截方法，所以使用 `iframe.src` 是经常会使用的方案。

优点：不存在漏洞问题、使用灵活，可以实现 H5 和 Native 页面的无缝切换。
	- 例如在某一页面需要快速上线的情况下，先开发出 H5 页面。某一链接填写的是 H5 链接，在对应的 Native 页面开发完成前先跳转至 H5 页面，待 Native 页面开发完后再进行拦截，跳转至 Native 页面，此时 H5 的链接无需进行修改。
缺点：使用 `iframe.src` 来发送 URL Scheme 需要对 URL 的长度作控制，使用复杂，速度较慢。

2. Native 向 Context 注入 API

基于 Webview 提供的能力，可以向 Window 上注入对象或方法。JS 通过这个对象或方法进行调用时，执行对应的逻辑操作，可以直接调用 Native 的方法。使用该方式时，JS 需要等到 Native 执行完对应的逻辑后才能进行回调里面的操作。

### Native 调用 JS

H5 将 JS 方法暴露在 Window 上给 Native 调用即可。

## CSS 样式权重

权重记忆口诀：从0开始，一个行内样式+1000，一个id选择器+100，一个属性选择器、class或者伪类+10，一个元素选择器，或者伪元素+1，通配符+0。

![CSS 权重图](image_02.png)

## 为什么使用 Vuex

**vuex 不是用来管理数据，而是用来管理数据的流动**。vuex 与 localstorage 解决的完全不是一个问题。

## Vue cli 的使用

实现模块化，LESS / SASS 转译，预处理，热加载，静态检测和自动化测试等

1. 双向绑定
2. 虚拟 DOM 渲染


## 在项目中，对项目做的一些优化

前端有一个 8s 原则，当加载一个页面超过 8s，那用户就会大量流失。所以对项目的优化就从这几个方面着手

1. 资源压缩/合并

## require 和 import 的区别

- `require` 是 CommoneJS 的语法，主要是 Node.js 使用，通过 `require` 同步加载模块，`export` 导出内容。在规范下，每一个 JS 文件都是独立的模块，每个模块都有独立的作用域，模块内的变量都是私有变量。

- `import` 是 ESM 的语法，现代浏览器原生支持，通过 `import` 加载模块，`export` 导出内容。ESM 在支持的浏览器环境下可以直接使用，在不支持的端需要编译/打包后使用。
	- ESM 加载模块的方式取决于所处的环境，Node.js 同步加载，浏览器端异步加载。

### 静态分析

> 静态分析是指在不运行程序的条件下，进行程序分析的方法

简而言之，前文里提到的静态分析就是指在运行代码之前就可判断出代码内有哪些代码使用到了，哪些没有使用到。

### Tree Shaking

> Tree Shaking 是一个通常用于描述移除 JavaScript 上下文中的未引用代码（dead-code）行为的术语。它依赖于 ES2015 中的 import 和 export 语句，用来检测代码模块是否被导出、导入，且被 JavaScript 文件使用。

简单来说，Tree Shaking 是一种依赖 ESM 模块静态分析实现的功能，它可以在编译时安全的移除代码中未使用的部分（webpack5 对 CommonJS 也进行了支持，在此不详细展开）。

#### Q: 为什么 ESM 默认支持

A: **ES6 模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析**，这就是 tree-shaking 的基础。

#### webpack5 对 CommonJS 如何支持

[系统学习前端效率工具](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B2%BE%E8%AE%B2-%E5%AE%8C/00%20%E5%BC%80%E7%AF%87%E8%AF%8D%20%20%E5%BB%BA%E7%AB%8B%E4%B8%8A%E5%B8%9D%E8%A7%86%E8%A7%92%EF%BC%8C%E5%85%A8%E9%9D%A2%E7%B3%BB%E7%BB%9F%E6%8E%8C%E6%8F%A1%E5%89%8D%E7%AB%AF%E6%95%88%E7%8E%87%E5%B7%A5%E7%A8%8B%E5%8C%96.md)


## 伪类和伪元素的区别

### 伪类

伪类是选择器的一种，它用于选择处于特定状态的元素，比如当鼠标指针悬浮在元素上面的时候。

伪类就是开头为冒号的关键字：`:pseudo-class-name`

### 伪元素

不过表现得是像你往标记文本中加入全新的 HTML 元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号 `::`。

## addEventListener 第三个参数

