---
title: 亲身面经
tags:
  - null
categories:
  - 面经
hidden: true
abbrlink: 2905717361
date: 2022-03-17 13:42:27
---

## 自我介绍

我叫邱佛，今年26岁，毕业于东华理工大学长江学院，专业是网络工程。毕业前以全职实习生的身份在迈坦信息科技有限公司担任前端开发，毕业后即转正入职该公司，我主要负责 PC 端官网及 移动端创新管家的构建与开发，使用的技术栈是 vue。现在在联合信用投资咨询有限公司担任前端开发，主要负责的项目有混合 App-H5 端，微信小程序、以及多个债评系统的开发。使用的技术栈也是 vue，小程序开发使用的 uni-app

## 自身有哪些优点与缺点

- 优点：我擅长合理地安排时间，因为我经常有多个项目同时缠身，所以我特别注意时间管理，分清楚任务的优先级，这样才能高效地工作，而不至于搞得焦头烂额。比方说，我会把产品需求，测试结果，会议安排，按优先级记录在我电脑的便签里面，当完成一个就会在后面做上标记，这样我就可以将这一天，这一周，甚至是因为一些大的需求将任务安排在一个月。尽量都安排得井井有条，就不会遗漏重要的事情。

- 缺点：我觉得我有时候会过分在意别人的感受，比方说，不敢直接表达不同意见，因为害怕自己的回答不够成熟，其实这样做很不利于快速有效地开展工作。我希望自己能够逐渐学会更加爽快，对人对事更加直接。将自己即使是错误的思考也尽量说出来，这样既能有更深的思考也能够学到更多。

## 将最近自己做过的几个比较重要的事情梳理下，讲清楚整体架构和思考改进

混合 APP - H5 端开发。
1. JSBridge 使用

2. 版本迭代而需要添加新的桥方法，强制要求 APP 更新

## 准备一个重要的问题，问面试官

### 假如有一面

1. 目前前端团队这边使用到的技术栈有哪些？
2. 请问公司对候选人有哪些要求？

### 假如有二面

1. 请问公司是否有技术分享交流活动？有的话，多久一次呢？
2. Code Review 如何实施？

### 假如有三面

1. 我在这个岗位上应该如何发展？会有哪些机会？
2. 入职之后在哪个项目组，项目是新成立还是已有的？

## 为何从上家公司离职

是这样子，我入职时期望的方向是做公司内部，能够提升公司影响力的 APP 项目，但因为业务的转型，公司要求我驻场银行，我服从公司安排且从年前的十一月份开始，到现在也一直在驻场开发，让我感到难受的不是路程，不是驻场，而是一直在做重复的内容。我自己还是更期待一些有挑战性的任务，不喜欢做一尘不变的事情。

## 如何快速让一个数组乱序

1. 利用 Array.prototype.sort 以及 Math.random 

``` javascript
arr.sort(() => Math.random() > 0.5 ? -1 : 1)
```

2. 经典洗牌算法实现

``` javascript
function shuffle(array) { 
	let arrayLength = array.length,   
		randomIndex, //随机数   
		tempItem; //临时存储元素  
	for (let i = arrayLength - 1; i >= 0; i--) {    
		randomIndex = Math.floor(Math.random() * (i + 1));    
		tempItem = array[randomIndex];
		array[randomIndex] = array[i];
		array[i] = tempItem;
	}
	return array;
}
console.log(shuffle(arr));
```

## JSBridge 原理

![JSBridge 的作用](image_01.png)

JavaScript 是运行在一个单独的 JS Context 中（例如，WebView 的 Webkit 引擎、JSCore）。由于这些 Context 与原生运行环境的天然隔离，我们可以将这种情况与 RPC（Remote Procedure Call，远程过程调用）通信进行类比，将 Native 与 JavaScript 的每次互相调用看做一次 RPC 调用。
在 JSBridge 的设计中，可以把前端看做 RPC 的客户端，把 Native 端看做 RPC 的服务器端，从而 JSBridge 要实现的主要逻辑就出现了：**通信调用（Native 与 JS 通信） 和 句柄解析调用**。（如果你是个前端，而且并不熟悉 RPC 的话，你也可以把**这个流程类比成 JSONP 的流程**）

## CSS 样式权重

权重记忆口诀：从0开始，一个行内样式+1000，一个id选择器+100，一个属性选择器、class或者伪类+10，一个元素选择器，或者伪元素+1，通配符+0。

![CSS 权重图](image_02.png)

## 为什么使用 Vuex

**vuex 不是用来管理数据，而是用来管理数据的流动**。vuex 与 localstorage 解决的完全不是一个问题。

## Vue cli 的使用

实现模块化，LESS / SASS 转译，预处理，热加载，静态检测和自动化测试等

1. 双向绑定
2. 虚拟 DOM 渲染


## 在项目中，对项目做的一些优化

前端有一个 8s 原则，当加载一个页面超过 8s，那用户就会大量流失。所以对项目的优化就从这几个方面着手

1. 资源压缩/合并

## require 和 import 的区别

- `require` 是 CommoneJS 的语法，主要是 Node.js 使用，通过 `require` 同步加载模块，`export` 导出内容。在规范下，每一个 JS 文件都是独立的模块，每个模块都有独立的作用域，模块内的变量都是私有变量。

- `import` 是 ESM 的语法，现代浏览器原生支持，通过 `import` 加载模块，`export` 导出内容。ESM 在支持的浏览器环境下可以直接使用，在不支持的端需要编译/打包后使用。
	- ESM 加载模块的方式取决于所处的环境，Node.js 同步加载，浏览器端异步加载。

### 静态分析

> 静态分析是指在不运行程序的条件下，进行程序分析的方法

简而言之，前文里提到的静态分析就是指在运行代码之前就可判断出代码内有哪些代码使用到了，哪些没有使用到。

### Tree Shaking

> Tree Shaking 是一个通常用于描述移除 JavaScript 上下文中的未引用代码（dead-code）行为的术语。它依赖于 ES2015 中的 import 和 export 语句，用来检测代码模块是否被导出、导入，且被 JavaScript 文件使用。

简单来说，Tree Shaking 是一种依赖 ESM 模块静态分析实现的功能，它可以在编译时安全的移除代码中未使用的部分（webpack5 对 CommonJS 也进行了支持，在此不详细展开）。

#### Q: 为什么 ESM 默认支持

A: **ES6 模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析**，这就是 tree-shaking 的基础。

#### webpack5 对 CommonJS 如何支持

[系统学习前端效率工具](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B2%BE%E8%AE%B2-%E5%AE%8C/00%20%E5%BC%80%E7%AF%87%E8%AF%8D%20%20%E5%BB%BA%E7%AB%8B%E4%B8%8A%E5%B8%9D%E8%A7%86%E8%A7%92%EF%BC%8C%E5%85%A8%E9%9D%A2%E7%B3%BB%E7%BB%9F%E6%8E%8C%E6%8F%A1%E5%89%8D%E7%AB%AF%E6%95%88%E7%8E%87%E5%B7%A5%E7%A8%8B%E5%8C%96.md)


## 伪类和伪元素的区别

### 伪类

伪类是选择器的一种，它用于选择处于特定状态的元素，比如当鼠标指针悬浮在元素上面的时候。

伪类就是开头为冒号的关键字：`:pseudo-class-name`

### 伪元素

不过表现得是像你往标记文本中加入全新的 HTML 元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号 `::`。

## addEventListener 第三个参数

