---
title: HTTP-进阶篇
tags:
  - 深入原理
categories:
  - HTTP
hidden: true
abbrlink: 3929373619
date: 2022-02-07 16:46:17
---

![](image_7.png)

# HTTP 状态码

- 1xx 信息性状态码 websocket upgrade
- 2xx 成功状态
  - 200 服务器已成功处理了请求
  - 204 没有响应体
  - 206 范围请求，暂停继续下载
- 3xx 
  > 服务器会在响应 `Header` 的 `Location` 字段中放上这个不同的 `URI`。浏览器可以使用 `Location` 中的 `URI` 进行自动重定向。
  - 301(永久) 请求的页面已永远跳转到新的 url
  - 302(临时) 允许各种各样的重定向，一般情况下都会实现为到 `GET` 的重定向，但是不能确保 `POST` 会重定向到 `POST`
  - 303(临时) 只允许任意请求到 `GET` 的重定向
  - 304 内容未修改，只返回请求头部信息
  - 307(临时) `307` 和 `302` 一样，除了不允许 `POST` 到 `GET` 的重定向
  - 308(永久) `308` 和 `301` 一样，除了不允许 `POST` 到 `GET` 的重定向
- 4xx 客户端错误状态码
  - 400 客户端参数错误
  - 401 没有登录
  - 403 登录了没权限，比如管理系统
  - 404 页面不存在
  - 405 禁用请求中指定的方法
- 5xx 服务端错误状态码
  - 500 服务器内部错误，无法完成请求
  - 502 错误网关，服务器作为网关或代理出现错误
  - 503 服务不可用，服务器目前无法使用
  - 504 网关超时，网关或代理服务器，未及时获取请求

#### 总结 302、303、307 (临时)重定向

`302` 允许各种各样的重定向，一般情况下都会实现为到 `GET` 的重定向，但是不能确保 `POST` 会重定向为 `POST`；
而 `303` 只允许任意请求到 `GET` 的重定向；
`307` 和 `302` 一样，除了不允许 `POST` 到 `GET` 的重定向。

#### 总结 301、308 (永久)重定向

`308` 的定义实际上和 `301` 是一致的，唯一的区别在于，`308` 状态码不允许浏览器将原本为 `POST` 的请求重定向到 `GET` 请求上。

#### 总结临时重定向与永久重定向对 SEO 的影响

`302` 重定向只是暂时的重定向，搜索引擎会抓取新的内容而保留旧的地址，因为服务器返回 `302`，所以，**搜索搜索引擎认为新的网址是暂时的**。
而 `301` 重定向是永久的重定向，搜索引擎在抓取新的内容的同时 **也将旧的网址替换为了重定向之后的网址**。

# HTTP 前生今世

| 协议版本 | 解决核心问题 | 解决方式 |
| :--: | :--: | :--: |
| 0.9 | HTML 文件传输 | 确立了客户端请求、服务端响应的通信流程 |
| 1.0 | 不同类型文件传输 | 设立头部字段 |
| 1.1 | 创建 / 断开 TCP 连接开销大 | 建立长连接进行复用 |
| 2 | 并发数有限 | 二进制分帧 |
| 3 | TCP 丢包阻塞 | 采用 UDP 协议 |

- HTTP 协议始于三十年前蒂姆·伯纳斯 - 李的一篇论文
- HTTP/0.9 是个简单的文本协议，只能获取文本资源；
- HTTP/1.0 确立了大部分现在使用的技术，但它不是正式标准；
- HTTP/1.1 是目前互联网上使用最广泛的协议，功能也非常完善；
- HTTP/2 基于 Google 的 SPDY 协议，注重性能改善，但还未普及；
- HTTP/3 基于 Google 的 QUIC 协议，是将来的发展方向

# HTTP 的优缺点

> 超文本传输协议，HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范

特点：
- **灵活可扩展**。一个是语法上只规定了基本格式，空格分隔单词，换行分隔字段等。另外一个就是传输形式上不仅可以传输文本，还可以传输图片、视频等任意数据
- **请求-应答模式**。通常而言，就是一方发送消息，另外一方要接受消息，或者是做出响应等
- **可靠传输**。HTTP 是基于 TCP/IP，因此把这一特性继承下来了。
- **无状态**。这个分场景说明。
  - 是好事儿：无状态会减少网络开销，比如直播行业
  - 是坏事儿：有时需要保存信息，比如购物系统，登录系统

缺点：
- **明文传输**。协议里的报文（主要指的是头部）不使用二进制数据，而是文本形式。这让 HTTP 的报文信息暴露给了外界，给攻击者带来了便利。
- **队头阻塞**。当 HTTP 开启长连接时，共用一个 `TCP` 连接，当某个请求时间过长时，其他的请求只能处于阻塞状态，这就是队头阻塞问题。

### HTTP 无状态连接

- `HTTP` 协议对于事务处理没有记忆能力
- 对同一个 `url` 请求没有上下文关系
- 每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况
- 服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器
- 请求过的资源，下一次会继续进行请求

### HTTP 协议无状态中的 “状态” 到底指的是什么？

- 【状态】 的含义就是：客户端与服务端在某次会话产生的数据
- 那么对应的 【无状态】 就意味着：这些数据不会被保留
- 通过增加 `cookie` 和 `session` 机制，现在的网络请求是有状态的
- 在没有状态的 `HTTP` 协议下，服务器也一定会保留你每次网络请求对数据的修改，但这跟保留每次访问的数据是不一样的，保留的只是会话产生的结果，而没有保留会话。

# HTTP 的请求方式

- `HTTP/1.0` 定义了三种请求方式：`GET`、`POST` 和 `HEAD` 方法
- `HTTP/1.1` 新增了五种请求方法：`OPTIONS`、`PUT`、`DELETE`、`TRACE` 和 `CONNECT`

`HTTP/1.1` 规定了以下请求方法（注意，都是大写）：
- `GET`：请求获取 `Request-URI` 所标识的资源
- `POST`：在 `Request-URI` 所标识的资源后附加新的数据
- `HEAD`：请求获取 `Request-URI` 所标识的资源的响应消息报头
- `PUT`：请求服务器存储一个资源，并用 `Request-URI` 作为其标识（修改数据）
- `DELETE`：请求服务器删除对应标识的资源
- `TRACE`：请求服务器回送收到的请求信息，主要用于测试与诊断
- `CONNECT`：建立连接隧道，用于代理服务器
- `OPTIONS`：列出可对资源实行的请求方式，用来跨域请求

> 从应用场景角度来看，`GET` 多用于无副作用，幂等的场景，例如搜索关键字。`POST` 多用于副作用，不幂等的场景，例如注册

### URI，Request-URI and URL 区分

I know URL is a subset of URI
http://www.example.org:56789/a/b/c.txt?t=win&s=chess#para5 is a URL and also a URI
every address we type in browsers can be called URL
http://www.example.org:56789/ is also a URI
the part: `a/b/c.txt?t=win&s=chess` is request-URI
the part: `para5` does not belong to the request-URI is just a fragment

## OPTIONS 方法有什么用

- `OPTIONS` 请求与 `HEAD` 类似，一般也用于客户端查看服务器的性能
- `OPTIONS` 方法请求服务器会返回该资源所支持的所有 `HTTP` 请求方法，该方法会用 “*” 来代替资源名称，向服务器发送 `OPTIONS` 请求，可以测试服务器功能是否正常
- JS 的 `XMLHttpRequest` 对象进行 CORS 跨域资源共享时，对于**复杂请求**，就是使用 `OPTIONS` 方法发送嗅探请求，以判断是否有对指定资源的访问权限。

### 简单请求和复杂请求

在日常的开发中，经常会遇到跨域资源共享，或者进行跨域接口访问的情况。跨域资源共享（[CORS](https://developer.mozilla.org/zh-CN/docs/Glossary/CORS)）机制允许 Web 应用服务器进行跨域访问控制。

> 跨域资源共享标准新增了一组 `HTTP` 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 `HTTP` 请求方法（特别是 `GET` 以外的 `HTTP` 请求，或者**搭配某些 `MIME 类型` 的 `POST` 请求**），浏览器必须首先使用 `OPTIONS` 方法发起一个 `预检请求（preflight request）`，从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 `HTTP` 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 `Cookies` 和 `HTTP` 认证相关数据）。

在涉及到 `CORS` 的请求中，我们会把请求分为 **简单请求** 和 **复杂请求**

#### 简单请求

满足以下条件的请求即为简单请求：
- 请求方法：`GET`、`POST`、`HEAD`
- 除了以下的请求头字段之外，没有自定义的请求头
  - Accept
  - Accept-Language
  - Content-Language
  - Content-Type
  - DPR
  - Downlink
  - Save-Data
  - Viewport-Width
  - Width
- `Content-Type` 的值只有以下三种(`Content-Type` 一般是指在 `POST` 请求中，`GET` 请求中设置没有实际意义)
  - text/plain
  - multipart/form-data
  - application/x-www-form-urlencoded

#### 复杂请求

非简单请求即为复杂请求。复杂请求我们也可以称之为在实际进行请求之前，需要发起预检请求的请求。

#### 简单请求与复杂请求的跨域设置

针对简单请求，在进行 `CORS` 设置的时候，我们只需要设置

``` http
Access-Control-Allow-Origin: *
// 如果只是针对某一个请求源进行设置的话，可以设置为具体的值
Access-Control-Allow-Origin: http://www.yourwebsite.com
```

针对复杂请求，我们需要设置不同的响应头。因为在预检请求的时候会携带相应的请求头信息

``` http
Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-CUSTOMER-HEADER, Content-Type
```

相应的响应头信息为：

``` http
Access-Control-Allow-Origin: http://foo.example
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
// 设置max age，浏览器端会进行缓存。没有过期之前真对同一个请求只会发送一次预检请求
Access-Control-Max-Age: 86400
```

如果发送的预检请求被进行了重定向，那大多数的浏览器都不支持对预检请求的重定向。我们可以通过先发送一个简单请求的方式，获取到重定向的url XHR.responseURL，然后再去请求这个url。

#### 附带身份凭证的请求

一般而言，对于跨域 `XMLHttpRequest` 或 `Fetch` 请求，浏览器不会发送身份凭证信息。如果要发送凭证信息，需要设置 `XMLHttpRequest` 的某个特殊标志位。
如果在发送请求的时候，给 `xhr` 设置了 `withCredentials` 为 true，从而向服务器发送 `Cookies`，如果服务端需要想客户端也发送 `Cookies` 的情况，需要服务器端也返回 `Access-Control-Allow-Credentials: true` 响应头信息。

对于附带身份凭证的请求，服务器不得设置 `Access-Control-Allow-Origin` 的值为“*”。

这是因为请求的首部中携带了 `Cookie` 信息，如果 `Access-Control-Allow-Origin` 的值为“*”，请求将会失败。而将 `Access-Control-Allow-Origin` 的值设置为 http://foo.example（请求源），则请求将成功执行。

## GET 和 POST 的区别

本质上，只是语义上的区别，`GET` 用于获取资源，`POST` 用于提交资源

具体差别
- 从缓存角度，`GET` 请求后浏览器会主动缓存，`POST` 默认情况下不能。
- 从参数角度，`GET` 请求内容一般放在 `URL` 中，因此不安全；`POST` 请求内容放在请求体中，相对而言较为安全，但是抓包情况下都是一样的。
- 从编码角度，`GET` 请求只能进行 URL 编码，只能接受 ASCII 码；而 `POST` 支持更多的编码类型且不对数据类型限制
- `GET` 请求幂等，`POST` 请求不幂等。
  - 幂等：指发送 M 和 N 次请求（两者不相同且都大于1），服务器上资源的状态一致
- `GET` 请求会一次性发送请求报文，`POST` 请求通常分为两个 `TCP` 数据包，首先发送 `header` 部分，如果服务器响应 100(comtinue)，然后发送 `body` 部分

# 队头阻塞问题

Q: 什么是队头阻塞问题？

A: 对于每一个 `HTTP` 请求而言，这些任务是会被放入一个任务队列中串行执行的，一旦队首任务请求太慢时，就会阻塞后面的请求处理，这就是 `HTTP 队头阻塞` 问题

有什么解决办法吗👇

#### 并发连接

我们知道对于一个域名而言，是允许分配多个长连接的，那么可以理解成增加了任务队列，也就是说不会导致一个任务阻塞了该任务队列的其他任务，在 `RFC 规范` 中规定客户端最多并发2个连接，不过实际情况就是要比这个还要多，例如 Chrome 中是6个

#### 域名分片

顾名思义，我们可以在一个域名下分出多个二级域名出来，而它们最终指向的都还是同一个服务器，这样子的话就可以并发处理的任务队列更多，也更好的解决了队头阻塞的问题。
举个例子，比如 `TianTian.com`，可以分出很多二级域名，比如 `Day1.TianTian.com`，`Day2.TianTian.com`，`Day3.TianTian.com`，这样子就可以有效解决队头阻塞问题。

# HTTPS 和 HTTP 区别

> HTTPS 要比 HTTP 多了 secure 安全性这个概念。实际上，HTTPS 并不是一个新的应用层协议，它其实就是 HTTP + TLS/SSL 协议组合而成，而安全性的保证正是 SSL/TLS 所做的工作。

SSL: 安全套接层（Secure Sockets Layer）
TLS: 传输层安全（Transport Layer Security）

现在主流的版本是 TLS/1.2, 之前的 TLS1.0、TLS1.1 都被认为是不安全的，在不久的将来会被完全淘汰。

**HTTPS 就是在 HTTP 与 TCP 中间加入了 SSL**

![HTTP 与 HTTPS 图解](image_1.png)

那么区别有哪些呢👇
- HTTP 是明文传输协议，HTTPS 协议是由 HTTP + SSL 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全
- HTTPS 较 HTTP 更加安全，对搜索引擎更友好，利于 SEO。
- HTTPS 标准端口 443，HTTP 标准端口 80
- HTTPS 需要用到 SSL 证书。

HTTPS 主要作用是：
- 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全
- 对网站，服务器进行真实身份认证

HTTPS 缺点：
- SSL 证书费用较很高，以及其在服务器上的部署、更新维护非常繁琐
- HTTPS 降低一定用户访问速度
  - HTTPS 多次握手
  - 网站改用 HTTPS 以后，由 HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用 301、302 跳转）
- HTTPS 涉及到的安全算法会消耗 CPU 资源，需要增加大量机器（HTTPS 访问过程需要加解密）

## HTTPS 握手过程

- 第一步，客户端给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法
- 第二步，服务端确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数
- 第三步，客户端确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务端
- 第四步，服务端使用自己的私钥，获取客户端发来的随机数（即Premaster secret）。
- 第五步，客户端和服务端根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来加密接下来的整个对话过程

#### 总结

- 客户端发起 HTTPS 请求，服务端返回证书，客户端对证书进行验证，验证通过后本地生成用于构造对称加密算法的随机数
- 通过证书中的公钥对随机数进行加密传输到服务端（随机对称密钥），服务端接收后通过私钥解密得到随机对称密钥，之后的数据交互通过对称加密算法进行加解密。（既有对称加密，也有非对称加密）

# HTTPS 工作原理

> `TLS/SSL` 的功能实现主要依赖于三类基本算法：`散列函数`、`对称加密` 和 `非对称加密`，其**利用非对称加密实现身份认证和密钥协商**，**对称加密算法采用协商的密钥对数据加密**，**基于散列函数验证信息的完整性**。

理解 HTTPS 工作原理前，先理解 `对称加密` & `非对称加密`

## 对称加密

> 加密和解密用同一个秘钥的加密方式叫做对称加密。Client客户端和Server端共用一套密钥，这样子的加密过程似乎很容易理解，但是随之会产生一些问题。

问题一: WWW万维网有许许多多的客户端，不可能都用秘钥A进行信息加密，这样子很不合理，所以解决办法就是使用一个客户端使用一个密钥进行加密。

问题二: **既然不同的客户端使用不同的密钥，那么对称加密的密钥如何传输？** 那么解决的办法只能是一端生成一个秘钥，然后通过 HTTP 传输给另一端，那么这样子又会产生新的问题。

问题三: 这个传输密钥的过程，又如何保证加密？**如果被中间人拦截，密钥也会被获取**。那么你会说对密钥再进行加密，那又怎么保存对密钥加密的过程，是加密的过程？

到这里，我们似乎想明白了，使用对称加密的方式，行不通。所以我们需要采用非对称加密👇

## 非对称加密

> 通过上面的分析，对称加密的方式行不通，那么我们来梳理一下非对称加密。采用的算法是RSA，所以在一些文章中也会看见 **传统RSA握手**，基于现在TLS主流版本是1.2，所以接下来梳理的是TLS/1.2握手过程。

非对称加密中，我们需要明确的点是👇
- 有一对秘钥，公钥和私钥。
- 公钥加密的内容，只有私钥可以解开，私钥加密的内容，**所有的公钥都可以解开**，这里说的公钥都可以解开，指的是**一对秘钥**。
- 公钥可以发送给所有的客户端，私钥只保存在服务器端。

## 主要工作流程

梳理起来，可以把 **TLS 1.2 握手** 过程分为主要的五步👇

![HTTPS 握手过程](image_2.png)

- 步骤一：Client发起一个 HTTPS 请求，连接 443 端口。这个过程可以理解成是 **请求公钥的过程**。
- 步骤二：Server端收到请求后，通过第三方机构私钥加密，会把数字证书（也可以认为是公钥证书）发送给Client。
- 步骤三：
  - 浏览器安装后会自动带一些权威第三方机构公钥，使用匹配的公钥对数字签名进行解密。
  - 根据签名生成的规则对网站信息进行本地签名生成，然后两者比对。
  - 通过比对两者签名，匹配则说明认证通过，不匹配则获取证书失败。
- 步骤四：在安全拿到 **服务器公钥** 后，客户端Client随机生成一个 **对称密钥**，使用 **服务器公钥（证书的公钥）** 加密这个 **对称密钥**，发送给Server(服务器)。
- 步骤五：Server(服务器)通过自己的私钥，对信息解密，至此得到了 **对称密钥**，此时两者都拥有了 **相同的对称密钥**。

接下来，就可以通过该对称密钥对传输的信息加密/解密啦，从上面图举个例子👇

- Client用户使用该对称密钥加密'明文内容B',发送给Server(服务器)
- Server使用该对称密钥进行解密消息，得到明文内容B。

接下来考虑一个问题，**如果公钥被中间人拿到纂改怎么办呢**？

![中间人攻击](image_3.png)

**客户端可能拿到的公钥是假的，解决办法是什么呢？**

### 第三方认证

**客户端无法识别传回公钥是中间人的，还是服务器的，这是问题的根本**。我们是不是可以通过某种规范可以让客户端和服务器都遵循某种约定呢？那就是通过 **第三方认证** 的方式

在 HTTPS 中，通过 **证书 + 数字签名** 来解决这个问题。

![数字证书生成方式](image_4.png)

这里唯一不同的是，假设对网站信息加密的算法是MD5，通过MD5加密后，**然后通过第三方机构的私钥再次对其加密，生成数字签名**。

这样子的话，数字证书包含有两个特别重要的信息👉**某网站公钥 + 数字签名**

> 我们再次假设中间人截取到服务器的公钥后，去替换成自己的公钥，因为有数字签名的存在，这样子**客户端验证发现数字签名不匹配**，这样子就防止中间人替换公钥的问题。

#### 那么客户端是如何去对比两者数字签名的呢？

- 浏览器会去安装一些比较权威的第三方认证机构的公钥，比如 VeriSign、Symantec 以及 GlobalSign 等等。
- 验证数字签名的时候，会**直接从本地拿到相应的第三方的公钥，对私钥加密后的数字签名进行解密得到真正的签名**。
- 然后客户端利用签名生成规则进行签名生成，**看两个签名是否匹配，如果匹配认证通过，不匹配则获取证书失败**。

### 数字签名作用

> 数字签名：将网站的信息，通过特定的算法加密，比如 MD5，加密之后，再通过第三方认证机构私钥进行加密，形成 **加密后的数字签名**。

第三方认证机构是一个公开的平台，**中间人可以去获取认证机构公钥**。

如果没有数字签名的话，这样子可以就会有下面情况👇

![缺少数字签名证书](image_4.png)

从上面我们知道，如果**只是对网站信息进行第三方机构私钥加密的话**，还是会受到欺骗。

因为没有认证，所以中间人也向第三方认证机构进行申请，然后拦截后把所有的信息都替换成自己的，客户端仍然可以解密，并且无法判断这是服务器的还是中间人的，最后造成数据泄露。

所以数字签名是维护数据信息安全的重要方法之一，可以解决伪造、抵赖、冒充和篡改等问题，数字签名的作用主要体现在以下几个方面：
- 数字签名可以**实现防重放攻击**。
  - 采用了对签名报文加盖时戳等或添加流水号等技术，就可以有效防止重放攻击。
- 数字签名可以**防止数据被伪造**。
  - 其他人不能伪造对消息的签名，因为**私有密钥只有签名者自己知道，所以其他人不可以构造出正确的签名结果数据**。
- 数字签名可以**防止数据被篡改**。
  - 数字签名与原始文件或摘要一起发送给接收者，一旦信息被篡改，接收者可通过计算摘要和验证签名来判断该文件无效，从而保证了文件的完整性。
- 数字签名可以**防止数据抵赖**。
  - 数字签名即可以作为身份认证的依据，也可以作为签名者签名操作的证据。要防止接收者抵赖，可以在数字签名系统中要求接收者返回一个自己签名的表示收到的报文，给发送者或受信任第三方。
- 数字签名可以**对数据进行多重加密**。
- 数字签名可以**实现客户的身份认证**。

## 总结

- HTTPS 就是使用 SSL/TLS 协议进行加密传输
- 大致流程：客户端拿到服务器的公钥（是正确的），然后客户端随机生成一个对称加密的秘钥，使用该公钥加密，传输给服务端，服务端再通过解密拿到该对称秘钥，后续的所有信息都通过该对称秘钥进行加密解密，完成整个 HTTPS 的流程。
- 第三方认证，**最重要的是数字签名，避免了获取的公钥是中间人的**。

# HTTP/2 理解

简要概括：`HTTP2.0` 是基于 1999 年发布的 `HTTP1.0` 之后的首次更新

- 提升访问速度
  - 二进制分帧：HTTP2.0 会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码
  - 头部压缩：HTTP 1.1 版本会出现 User-Agent、Cookie、Accept、Server、Range 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2.0 使用 `HPACK 算法` 进行压缩。
  - 允许多路复用
- 服务器端推送
  - 浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求。

## 多路复用

`HTTP 1.1` 中，如果想并发多个请求，必须使用多个 TCP 链接，而浏览器为了控制资源，会对单个域名有6-8个的 TCP 链接请求限制。

在 `HTTP 2` 中：
- 同域名下所有通信都在单个链接上完成
- 单链接可以承载任意数量的双向数据流
- 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧可以乱序发送。乱序发送却能根据帧首部的流标识(`Stream ID`)进行重新组装。根据流标识，接收方就能从乱序的二进制帧中选择 ID 相同的帧，按照顺序组装成 `请求/响应报文`

## 服务器推送相比较 HTTP/1.1 的优势

- 推送资源可以由不同页面共享
- 服务器可以按照优先级推送资源
- 客户端可以缓存推送的资源
- 客户端可以拒收推送过来的资源

### HTTP2.0 与 WebSocket 的关系是怎么样的？

`HTTP 协议` 和 `WebSocket 协议` 都是应用层的协议，两者应用场景不一样。

`HTTP2` 虽然支持服务器推送资源到客户端，**但那不是应用程序可以感知的，主要是让浏览器（用户代理）提前缓存静态资源**，所以我们不能指望 `HTTP2` 可以像 `WebSocket` 建立双向实时通信。

## 二进制分帧

之前是明文传输，不方便计算机解析，对于回车换行符来说到底是内容还是分隔符，都需要内部状态机去识别，这样子效率低。HTTP/2采用二进制格式，全部传输01串，便于机器解码。

这样子一个报文格式就被拆分为一个个二进制帧，用 `Headers帧` 存放头部字段，`Data帧` 存放请求体数据。这样子的话，就是一堆乱序的二进制帧，它们不存在先后关系，**因此不需要排队等待，解决了 `HTTP 队头阻塞问题`**。

> **TCP 的队头阻塞并没有彻底解决**。在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的。但当 HTTP/2 出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该 TCP 连接中的所有请求。

在客户端与服务器之间，双方都可以互相发送二进制帧，这样子双向传输的序列，称为`流`，所以 HTTP/2 中**以流来表示一个 TCP 连接上进行多个数据帧的通信，这就是多路复用概念**。

#### Q: 那乱序的二进制帧，是如何组装成对于的报文呢？

- 乱序，指的是不同 ID 的 Stream 是乱序的，对于同一个 Stream ID 的帧是顺序传输的
- 接收方收到二进制帧后，将相同的 Stream ID 组装成完整的请求报文和响应报文。
- 二进制帧中的一些字段，控制着 `优先级` 和 `流量控制` 等功能，这样子的话，就可以设置数据帧的优先级，让服务器处理重要资源，优化用户体验。

# DNS 如何工作

从两张图中，就能看出 DNS 是如何工作的

![递归查询](image_5.png)
![迭代查询](image_6.png)

## 递归查询和迭代查询

- 递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。**使用递归查询，用户只需要发出 `一次查询请求`**。
- 迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。**使用迭代查询，用户需要发出 `多次的查询请求`**。

所以一般而言，**本地服务器查询是递归查询**，而**本地 DNS 服务器向其他域名服务器请求的过程是迭代查询**的过程

#### Q: DNS 为什么使用 UDP 协议作为传输层协议？

> DNS 使用 UDP 协议作为传输层协议的主要原因是为了**避免使用 TCP 协议时造成的连接时延**

- 为了得到一个域名的 IP 地址，往往会向多个域名服务器查询，如果使用 TCP 协议，那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢。
- 大多数的地址查询请求，都是浏览器请求页面时发出的，这样会造成网页的等待时间过长。

## DNS 实现负载均衡

**DNS 可以用于在冗余的服务器上实现负载平衡**。因为现在一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应多个服务器地址。当用户向网站域名请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。

> 这种方式有一个缺点就是，**由于 DNS 服务器中存在缓存**，所以有可能一个服务器出现故障后，域名解析仍然返回的是那个 IP 地址，就会造成访问的问题。

## 总结

- DNS域名系统，是应用层协议，运行UDP协议之上，使用端口43。
- 查询过程，本地查询是递归查询，依次通过浏览器缓存 —>> 本地hosts文件 —>> 本地DNS解析器 —>>本地DNS服务器 —>> 其他域名服务器请求。 接下来的过程就是迭代过程。
- 递归查询一般而言，发送一次请求就够，迭代过程需要用户发送多次请求。

# 说一说正向代理和反向代理

## 正向代理

我们常说的代理也就是指正向代理，正向代理的过程，**它隐藏了真实的请求客户端**，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求。

## 反向代理

这种代理模式下，**它隐藏了真实的服务端**，当我们向一个网站发起请求的时候，背后可能有成千上万台服务器为我们服务，具体是哪一台，我们不清楚，我们只需要知道反向代理服务器是谁就行，而且反向代理服务器会帮我们把请求转发到真实的服务器那里去，*一般而言反向代理服务器一般用来实现负载平衡*。

### 负载平衡的两种实现方式？

- 一种是使用反向代理的方式，用户的请求都发送到反向代理服务上，然后由反向代理服务器来转发请求到真实的服务器上，以此来实现集群的负载平衡。
- 另一种是 DNS 的方式，DNS 可以用于在冗余的服务器上实现负载平衡。这种方式有一个缺点就是，由于 DNS 服务器中存在缓存，所以有可能一个服务器出现故障后，域名解析仍然返回的是那个 IP 地址，就会造成访问的问题。

# HTTP/HTTPS 协议总结

#### 1.0 协议缺陷:

无法复用链接，完成即断开，重新慢启动和 TCP 3次握手
head of line blocking: 线头阻塞，导致请求之间互相影响

#### 1.1 改进:

- 长连接(默认 keep-alive)，复用
- host 字段指定对应的虚拟站点
- 新增功能:
  - 断点续传
  - 身份认证
  - 状态管理
  - cache 缓存
    - Cache-Control
    - Expires
    - Last-Modified
    - Etag

#### 2.0:

- 多路复用
- 二进制分帧层: 应用层和传输层之间
- 首部压缩
- 服务端推送

#### HTTPS: 较为安全的网络传输协议

- 证书(公钥)
- SSL 加密
- 端口 443

#### TCP:

- 三次握手
- 四次挥手
- 滑动窗口: 流量控制
- 拥塞处理
  - 慢开始
  - 拥塞避免
  - 快速重传
  - 快速恢复

#### 缓存策略: 可分为 强缓存 和 协商缓存

- `Cache-Control/Expires`: 浏览器判断缓存是否过期，未过期时，直接使用强缓存，`Cache-Control` 的 `max-age` 优先级高于 `Expires`
- 当缓存已经过期时，使用协商缓存
  - 唯一标识方案: `Etag(response 携带)` & `If-None-Match(request携带，上一次返回的 Etag)`: 服务器判断资源是否被修改
  - 最后一次修改时间: `Last-Modified(response)` & `If-Modified-Since(request，上一次返回的Last-Modified)`
  - 如果一致，则直接返回 304 通知浏览器使用缓存
  - 如不一致，则服务端返回新的资源
- `Last-Modified` 缺点：
  - 周期性修改，但内容未变时，会导致缓存失效
  - 最小粒度只到 `s`，`s` 以内的改动无法检测到
- `Etag` 的优先级高于 `Last-Modified`

# 为什么要有 WebSocket

> 其实 `WebSocket` 与 `HTTP/2` 一样，都是为了解决 `HTTP` 某方面的缺陷而诞生的。`HTTP/2` 针对的是 `“队头阻塞”`，而 `WebSocket` 针对的是 `“请求 - 应答”通信模式`。

#### Q: “请求 - 应答”有什么不好的地方呢？

A:
- “请求 - 应答”是一种“半双工”的通信模式，**同一时刻只能一个方向上有动作，传输效率低**。更关键的一点，服务器只能“被动”响应客户端的请求，无法主动向客户端发送数据。
- 虽然后来的 HTTP/2、HTTP/3 新增了 Stream、Server Push 等特性，但“请求 - 应答”依然是主要的工作方式。
- 在 WebSocket 出现之前，在浏览器环境里用 JavaScript 开发实时 Web 应用很麻烦。因为浏览器是一个“受限的沙盒”，不能用 TCP，只有 HTTP 协议可用，所以就出现了很多“变通”的技术，**“轮询”（polling）就是比较常用的的一种**。
- 简单地说，轮询就是不停地向服务器发送 HTTP 请求，问有没有数据。但轮询的缺点也很明显，反复发送无效查询请求耗费了大量的带宽和 CPU 资源，非常不经济。
- 所以，为了克服 HTTP“请求 - 应答”模式的缺点，WebSocket 就“应运而生”了

## WebSocket 的特点

- WebSocket 是一个**真正“全双工”的通信协议**，与 TCP 一样，客户端和服务器都可以随时向对方发送数据
- WebSocket 采用了**二进制帧结构**，语法、语义与 HTTP 完全不兼容，但因为它的主要运行环境是浏览器，为了便于推广和应用，就不得不“搭便车”，在使用习惯上尽量向 HTTP 靠拢，这就是它名字里“Web”的含义。
- 服务方面，WebSocket 没有使用 TCP 的“IP 地址 + 端口号”，而是延用了 HTTP 的 URI 格式，但开头的协议名不是“http”，引入的是两个新的名字：“ws”和“wss”，分别表示明文和加密的 WebSocket 协议。
- **WebSocket 的默认端口也选择了 80 和 443**，因为现在互联网上的防火墙屏蔽了绝大多数的端口，只对 HTTP 的 80、443 端口“放行”，**所以 WebSocket 就可以“伪装”成 HTTP 协议，比较容易地“穿透”防火墙，与服务器建立连接**

## WebSocket 的握手

> 和 TCP、TLS 一样，WebSocket 也要有一个握手过程，然后才能正式收发数据

**利用了 HTTP 本身的“协议升级”特性**，“伪装”成 HTTP，这样就能绕过浏览器沙盒、网络防火墙等等限制，这也是 WebSocket 与 HTTP 的另一个重要关联点。

WebSocket 的握手**是一个标准的 HTTP GET 请求**，但**要带上两个协议升级的专用头字段**：

- `Connection: Upgrade`，表示要求协议“升级”；
- `Upgrade: websocket`，表示要“升级”成 WebSocket 协议。

另外，为了防止普通的 HTTP 消息被“意外”识别成 WebSocket，握手消息还增加了两个额外的认证用头字段（所谓的“挑战”，Challenge）：

- `Sec-WebSocket-Key`：一个 Base64 编码的 16 字节随机数，作为简单的认证密钥；
- `Sec-WebSocket-Version`：协议的版本号，当前必须是 13。

``` http
Get HTTP/1.1
Upgrade: websocket
Host: location
Sec-WebSocket-Key: y7KXwBSpVrxtkR0O+bQt+Q==
Sec-WebSocket-Version: 13
Connection: Upgrade
```

服务器收到 HTTP 请求报文，看到上面的四个字段，就知道这不是一个普通的 GET 请求，而是 WebSocket 的升级请求，于是就不走普通的 HTTP 处理流程，而是构造一个特殊的 `“101 Switching Protocols”` 响应报文，通知客户端，接下来就不用 HTTP 了，全改用 WebSocket 协议通信，服务器端返回后的 `Header`：

- `Sec-WebSocket-Accept`：值是服务端采用与客户端一致的密钥计算出来后返回客户端的。

``` http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: K7DJLdLooIwIG/MOpvWFB3y3FE8=
```

# UDP 和 TCP 的区别

- TCP协议在传输数据段的时候要给段标号；UDP协议不
- TCP协议可靠；UDP协议不可靠
- TCP协议是面向连接；UDP协议采用无连接
- TCP协议的发送方要确认接收方是否收到数据段（3次握手协议）
- TCP协议采用窗口技术和流控制

| 特性 | TCP | UDP |
| :--: | :--: | :--: |
| 是否连接 | 面向连接 | 面向非连接 |
| 传输可靠性 | 可靠 | 不可靠 |
| 应用场景 | 传输大量数据 | 传输少量数据 |
| 速度 | 慢 | 快 |