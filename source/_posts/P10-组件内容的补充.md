---
title: P10 组件内容的补充
tags: []
categories:
  - React
abbrlink: 3425332428
date: 2021-12-07 19:32:43
---

# Portals

> Portals 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。
> 
> 注意：尽管 portal 可以被放置在 DOM 树中的任何地方，但在任何其他方面，**其行为和普通的 React 子节点行为一致**。**由于 portal 仍存在于 React 树， 且与 DOM 树 中的位置无关**，那么无论其子节点是否是 portal，像 context 这样的功能特性都是不变的。这包含事件冒泡。

` ReactDOM.createProtals(child, container) `

第一个参数（`child`）是任何可渲染的 React 子元素，例如一个元素，字符串或 `fragment`。第二个参数（`container`）是一个 DOM 元素。

## 自创建利用 Portals 创建不挂载在 root DOM 元素上的 React 组件

通常我们创建的 React 组件都是挂载在离该元素最近的父节点上，然而，有时将子组件插入到 DOM 节点中的不同位置也是有好处的，典型的案例就是当父节点的 css 包含 `overflow: hidden`，或 `z-index` 样式时，但你需要子组件能够不受父组件容器的影响。例如：对话框、悬浮卡以及提示框等：

1. 在入口文件 `index.html` 中手动的写入一个用来单独挂载 `Portals` 中的子组件的 `container`

``` javascript
<div id="root"></div>
<!-- 手动新加入的一个节点，用来挂载 Portals -->
<div id="container"></div>
```

2. 在需要挂载的父组件中编写相应的组件：

``` javascript
import React, { PureComponent } from 'react';
/* createPortal 方法在 ReactDOM 中 */
import ReactDOM from "react-dom";
/* 一些定位样式的编写在 style.css 中 */
import "./style.css";

function Home(props) {
    return (
        <h2>Home</h2>
    )
}

function Tip(props) {
    return (
        <div>
            <p>{props.tipVal}</p>
            <p>萨瓦迪卡</p>
            <p>靠你吉瓦</p>
        </div>
    )
}

class App extends PureComponent {
    constructor(props) {
        super(props);
        this.state = {
            tipVal: '你好'
        }
    }
    render() { 
        return (
            <div>
                <Home />
                {
                    /* 关键性代码 */
                    ReactDOM.createPortal(
                        <Tip tipVal={this.state.tipVal}/>,
                        document.getElementById('container')
                    )
                }
            </div>
        );
    }
}
```

这样子，一个简单的 `Portals` 就创建完成了。

但是在这个案例中，我们可以发现有两个点是比较繁琐的：
1. 需要我们手动的在 `index.html` 入口文件中写入一个专门节点 `module`
2. 每有一个需要单独独立在 root 节点外就需要重复性的编写 `ReactDOM.createPortal(chilren, contain)` 方法。

尤其是在第三方 UI 库中，是无法要求使用者手动去添加专门节点用于被 `Portal` 使用的。因此专门创建这么个高阶函数用来接收相应的组件返回 `Portal` 组件尤为重要。

1. 创建 `portalComponent` 高阶组件用来接收希望放入 `#portal` DOM 节点内的 React 组件
``` javascript
function portalsComponent(WrappedComponent) {
    /* 1. 创建一个 div 用来当作 Portal 的根 DOM 节点 */
    const div = document.createElement('div')
    div.id = 'portal'
    /* 2. 将该 div 插入 body 中 */
    document.body.appendChild(div)
    return class NewComponent extends PureComponent {
        render () {
            return createPortal(
                <WrappedComponent {...this.props}/>,
                div
            )
        }
    }
}
```
2. 使用时：
``` javascript
const PortalTip = portalsComponent(Tip)

class App extends PureComponent {
    constructor(props) {
        super(props);
        this.state = {
            tipVal: 'hello'
        }
    }
    render() { 
        return (
            <div>
                <PortalTip tipVal={this.state.tipVal}/>
            </div>
        );
    }
}
```

# Fragments

> React 中的一个常见模式是一个组件返回多个元素。`Fragments` 允许你将子列表分组，而无需向 DOM 添加额外节点。

使用方式有两种：
1. 普通方式：`<Fragment></Fragment>` 
2. 短语句方式： `<></>`

但是有两点需要注意：
1. `Fragments` 只支持 `key` 这一个属性，未来可能会添加对其他属性的支持，例如事件
2. 短语句方式 `<></>` 不支持使用属性。

``` javascript
...
/* 1. 一般的使用方式 */
<Fragment>
    <h2>朋友们</h2>
    {/* 2. 短语句方式 */}
    <>
        <h3>列表</h3>
    </>
    <div>
        {
            this.state.friends.map((item, index) => {
                return (
                    /* 使用显式 <React.Fragment> 语法声明的片段可能具有 key */
                    <Fragment key={index}>
                        <p>{item.name}</p>
                        <p>{item.age}</p>
                        <hr />
                    </Fragment>
                )
            })
        }
    </div>
</Fragment>
...
```

# 严格模式：`React.StrictMode`

> `StrictMode` 是一个用来突出显示应用程序中潜在问题的工具。与 `Fragment` 一样，`StrictMode` 不会渲染任何可见的 UI。它为其后代元素触发额外的检查和警告。
> 
> 注意：严格模式检查**仅在开发模式下运行**，不会影响生产构建

我们可以在应用程序的任意部分启用严格模式。

`StrictMode` 目前有助于：
1. 识别不安全的生命周期
2. 关于使用过时字符串 ref API 的警告
3. 关于使用废弃的 findDOMNode 方法的警告
    - 在之前的 React API 中，可以通过 `findDOMNode` 来获取 DOM，不过现已不再推荐使用。
4. 检测意外的副作用
    - 在被包裹了 `StrictMode` 的组件中，开发模式下，`constructor` 方法会被故意执行两次。
    - 故意执行两次的原因是查看 `constructor` 中写的一些逻辑代码被调用多次时，是否会产生一些副作用
5. 检测过时的 `context` API
    - 早期的 `Context` 是通过 static 属性声明 `Context` 对象属性，通过 `getChildContext` 返回 `Context` 对象等方式来使用 `Context` 的

---
---

> 参考：
> 1. Portal 的使用参考 `Ant-design`：[https://github.com/ant-design/ant-design/blob/master/components/modal/confirm.tsx#L55](https://github.com/ant-design/ant-design/blob/master/components/modal/confirm.tsx#L55)


